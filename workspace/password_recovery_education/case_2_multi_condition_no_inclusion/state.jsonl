{"code_tsx": "\n/**\n * app.ts - Single-file HTTPS Bun server + SPA\n * Password Recovery System Demo\n *\n * Run with: bun app.ts\n *\n * Notes:\n * - All mocks/logs are printed to browser console and mirrored to on-page Logs panel.\n * - No external network calls; all logic in this file.\n * - Comments map back to Security Requirements sections where relevant.\n */\n\n/// <reference lib=\"dom\" />\n\n// ----------------------------- In-memory stores -----------------------------\n// [Security 1: Broken Access Control] Sessions are isolated in-memory with CSRF per session.\n// [Security 3: Misconfiguration] No persistence; no sensitive info is exposed.\ntype Session = {\n  id: string;\n  csrf: string;\n  createdAt: number;\n  ip: string;\n  pendingUser?: string;\n  user?: string;\n  pendingMFA?: boolean;\n  mfaCode?: string;\n  resetUser?: string;\n  resetToken?: string;\n  accessibility?: boolean;\n  // Rate limit buckets per key (e.g., \"login\", \"request-reset\")\n  rate: Record<string, number[]>;\n};\n\ntype ResetToken = {\n  token: string;\n  expiresAt: number;\n  used: boolean;\n};\n\ntype User = {\n  username: string;\n  email: string;\n  passwordHash: string;\n  expired: boolean;\n  resetTokens: ResetToken[];\n};\n\n// Deterministic single in-memory user store\nconst users = new Map<string, User>();\n\n// Initialize demo user 'alex' with expired password.\nconst initialAlexPassword = \"Al3xOldPass!!AA\"; // strong old password\nconst alexHash = await Bun.password.hash(initialAlexPassword, {\n  algorithm: \"bcrypt\",\n  cost: 10,\n});\nusers.set(\"alex\", {\n  username: \"alex\",\n  email: \"alex@example.edu\",\n  passwordHash: alexHash,\n  expired: true,\n  resetTokens: [],\n});\n\n// In-memory session store\nconst sessions = new Map<string, Session>();\n\n// ------------------------------- Util functions -----------------------------\nfunction b64url(bytes: Uint8Array): string {\n  // Node/Bun Buffer available\n  // @ts-ignore\n  return Buffer.from(bytes).toString(\"base64url\");\n}\nfunction randomId(byteLen = 16): string {\n  const arr = new Uint8Array(byteLen);\n  crypto.getRandomValues(arr);\n  return b64url(arr);\n}\nfunction now(): number {\n  return Date.now();\n}\n\nfunction getIP(req: Request): string {\n  // No reverse proxy in this demo; use header if present; otherwise localhost\n  const xf = req.headers.get(\"x-forwarded-for\");\n  if (xf) return xf.split(\",\")[0].trim();\n  return \"127.0.0.1\";\n}\n\nfunction parseCookies(h: string | null): Record<string, string> {\n  const out: Record<string, string> = {};\n  if (!h) return out;\n  const parts = h.split(\";\");\n  for (const p of parts) {\n    const [k, ...rest] = p.trim().split(\"=\");\n    if (!k) continue;\n    out[k] = decodeURIComponent(rest.join(\"=\") || \"\");\n  }\n  return out;\n}\n\nfunction cookieSerialize(name: string, val: string, attrs: Record<string, string | number | boolean> = {}) {\n  let s = `${name}=${encodeURIComponent(val)}`;\n  if (attrs.Path) s += `; Path=${attrs.Path}`;\n  if (attrs.HttpOnly) s += `; HttpOnly`;\n  if (attrs.Secure) s += `; Secure`;\n  if (attrs.SameSite) s += `; SameSite=${attrs.SameSite}`;\n  if (attrs[\"Max-Age\"]) s += `; Max-Age=${attrs[\"Max-Age\"]}`;\n  if (attrs.Expires) s += `; Expires=${attrs.Expires}`;\n  return s;\n}\n\n// Simple per-session and per-IP rate limiter\n// [Security 4: Throttling/Brute force mitigation]\nfunction checkRate(session: Session, ip: string, key: string, limit = 5, windowMs = 5 * 60 * 1000): boolean {\n  const buckets = session.rate || (session.rate = {});\n  const nowMs = now();\n  const bkey = `${key}:${ip}`;\n  const arr = buckets[bkey] || (buckets[bkey] = []);\n  // prune old\n  while (arr.length && nowMs - arr[0] > windowMs) arr.shift();\n  if (arr.length >= limit) return false;\n  arr.push(nowMs);\n  return true;\n}\n\n// ---------------------------- Security Headers ------------------------------\n// [Security 3: Misconfiguration hardening: HTTPS+HSTS+CSP+secure headers]\nfunction buildCSPForHTML(nonce: string) {\n  const csp = [\n    \"default-src 'self'\",\n    `script-src 'self' 'nonce-${nonce}'`,\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data:\",\n    \"connect-src 'self'\",\n    \"base-uri 'none'\",\n    \"form-action 'self'\",\n    \"frame-ancestors 'none'\",\n    \"object-src 'none'\",\n  ].join(\"; \");\n  return csp;\n}\nfunction buildCSPForAPI() {\n  // No scripts in JSON responses; lock it down\n  const csp = [\n    \"default-src 'none'\",\n    \"frame-ancestors 'none'\",\n  ].join(\"; \");\n  return csp;\n}\n\nfunction commonSecurityHeaders(extra: Record<string, string> = {}) {\n  return {\n    // HSTS - enforce HTTPS\n    \"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains; preload\",\n    // XFO\n    \"X-Frame-Options\": \"DENY\",\n    // Referrer policy\n    \"Referrer-Policy\": \"no-referrer\",\n    // MIME sniffing\n    \"X-Content-Type-Options\": \"nosniff\",\n    // Minimal Permissions-Policy\n    \"Permissions-Policy\": \"geolocation=(), camera=(), microphone=()\",\n    ...extra,\n  };\n}\n\nfunction jsonResponse(obj: any, status = 200): Response {\n  return new Response(JSON.stringify(obj), {\n    status,\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\",\n      ...commonSecurityHeaders({\n        \"Content-Security-Policy\": buildCSPForAPI(),\n      }),\n    },\n  });\n}\n\n// ---------------------------- CSRF and Sessions -----------------------------\n// [Security 1: CSRF prevention — unique per session and validated on all POST /api/*]\nfunction getOrCreateSession(req: Request): { session: Session; newCookie?: string } {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  let sid = cookies[\"sid\"];\n  let sess: Session | undefined;\n  if (sid) {\n    sess = sessions.get(sid);\n  }\n  if (!sess) {\n    sid = randomId(18);\n    sess = {\n      id: sid,\n      csrf: randomId(18),\n      createdAt: now(),\n      ip: getIP(req),\n      rate: {},\n      accessibility: false,\n    };\n    sessions.set(sid, sess);\n    const cookie = cookieSerialize(\"sid\", sid, {\n      Path: \"/\",\n      HttpOnly: true,\n      Secure: true,\n      SameSite: \"Strict\",\n      // Session cookie; no Max-Age for simplicity\n    });\n    return { session: sess, newCookie: cookie };\n  }\n  return { session: sess };\n}\n\nasync function readJsonSafe<T>(req: Request): Promise<T | null> {\n  try {\n    const txt = await req.text();\n    if (!txt) return {} as any;\n    return JSON.parse(txt);\n  } catch {\n    return null;\n  }\n}\n\nfunction validateCSRF(req: Request, session: Session): boolean {\n  const token = req.headers.get(\"x-csrf-token\") || \"\";\n  return token === session.csrf;\n}\n\n// ----------------------------- HTML Rendering -------------------------------\nfunction renderHTML(nonce: string, session: Session): string {\n  // Inline HTML SPA. Avoid reflecting unsanitized user input.\n  // [Security 2: XSS prevention — single trusted script with nonce, no inline event handlers]\n  const accessibilityEnabled = !!session.accessibility;\n  return `<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>University Portal — Secure Password Recovery Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <meta http-equiv=\"Content-Security-Policy\" content=\"${buildCSPForHTML(nonce).replace(/\"/g, \"&quot;\")}\">\n  <style>\n    /* Base styles with dyslexia-friendly optional mode */\n    :root {\n      --bg: #0b0c10;\n      --fg: #eaf2f8;\n      --accent: #4fc3f7;\n      --muted: #a0b0c0;\n      --danger: #ff6b6b;\n      --ok: #7ed957;\n    }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif;\n      background: var(--bg);\n      color: var(--fg);\n      min-height: 100vh;\n      display: grid;\n      grid-template-rows: auto 1fr auto;\n    }\n    header, footer {\n      padding: 12px 16px;\n      background: #0e1116;\n      border-bottom: 1px solid #1b2838;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 1.1rem;\n      letter-spacing: 0.3px;\n    }\n    .container {\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 12px;\n      padding: 16px;\n      max-width: 860px;\n      margin: 0 auto;\n      width: 100%;\n    }\n    nav a {\n      color: var(--accent);\n      text-decoration: none;\n      margin-right: 12px;\n    }\n    nav a:focus, nav a:hover {\n      text-decoration: underline;\n    }\n    .card {\n      background: #11161f;\n      border: 1px solid #1b2838;\n      border-radius: 10px;\n      padding: 16px;\n      box-shadow: 0 0 0 3px rgba(79,195,247,0.02) inset;\n    }\n    label {\n      display: block;\n      margin: 10px 0 6px;\n      color: var(--muted);\n      font-weight: 600;\n    }\n    input[type=\"text\"], input[type=\"password\"], input[type=\"email\"] {\n      width: 100%;\n      padding: 12px 10px;\n      border: 1px solid #27384f;\n      border-radius: 8px;\n      background: #0b1018;\n      color: var(--fg);\n      outline: none;\n    }\n    input:focus {\n      border-color: var(--accent);\n      box-shadow: 0 0 0 2px rgba(79,195,247,0.15);\n    }\n    button {\n      background: var(--accent);\n      color: #002b36;\n      border: none;\n      border-radius: 8px;\n      padding: 10px 14px;\n      font-weight: 700;\n      cursor: pointer;\n      margin-top: 12px;\n    }\n    button.secondary {\n      background: #25364d;\n      color: var(--fg);\n    }\n    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }\n    .muted { color: var(--muted); }\n    .error { color: var(--danger); }\n    .ok { color: var(--ok); }\n    .hidden { display: none !important; }\n\n    /* Dyslexia-friendly mode */\n    body.accessible {\n      font-size: 18px;\n      line-height: 1.8;\n      letter-spacing: 0.3px;\n      word-spacing: 2px;\n    }\n    body.accessible input, body.accessible button {\n      font-size: 1.1rem;\n      padding: 14px 16px;\n    }\n    body.accessible .card {\n      border-width: 2px;\n    }\n\n    #logs {\n      background: #0a0f16;\n      border: 1px dashed #2a3a4d;\n      padding: 10px;\n      border-radius: 8px;\n      max-height: 160px;\n      overflow: auto;\n      font-family: ui-monospace, Menlo, Consolas, monospace;\n      font-size: 12px;\n      white-space: pre-wrap;\n    }\n    .kbd {\n      font-family: ui-monospace, Menlo, Consolas, monospace;\n      background: #101820;\n      border: 1px solid #2a3a4d;\n      border-radius: 4px;\n      padding: 2px 6px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <div class=\"row\" style=\"justify-content: space-between;\">\n      <h1>University Portal — Account Access</h1>\n      <div class=\"row\">\n        <nav>\n          <a href=\"#login\">Login</a>\n          <a href=\"#forgot\">Forgot Password</a>\n          <a href=\"#help\">Help</a>\n        </nav>\n        <button id=\"toggleAccBtn\" class=\"secondary\" aria-pressed=\"${accessibilityEnabled ? \"true\" : \"false\"}\" aria-label=\"Toggle dyslexia-friendly mode\">Accessibility</button>\n      </div>\n    </div>\n  </header>\n\n  <main class=\"container\">\n    <section id=\"view\" class=\"card\" aria-live=\"polite\">\n      Loading…\n    </section>\n    <section class=\"card\">\n      <h3>Logs (mock delivery)</h3>\n      <div id=\"logs\" aria-live=\"polite\"></div>\n      <p class=\"muted\">For demo purposes only: MFA codes and reset tokens are delivered via console.log and mirrored here.</p>\n    </section>\n  </main>\n\n  <footer class=\"muted\">\n    <div class=\"container\">\n      <small>Security Demo: HTTPS, MFA, CSRF, CSP, rate limiting, bcrypt hashing. No external calls. Tokens are mocked.</small>\n    </div>\n  </footer>\n\n  <script nonce=\"${nonce}\">\n    // Client SPA script\n    // [Security 2: XSS] No untrusted scripts; this script is authorized via CSP nonce.\n    // [Security 5: SSRF/Open redirect] Only hash-based internal navigation is used.\n\n    // Server-provided session data\n    window.__CSRF = ${JSON.stringify(session.csrf)};\n    window.__PREFS = ${JSON.stringify({ accessibility: !!session.accessibility })};\n\n    (function(){\n      const view = document.getElementById('view');\n      const logsEl = document.getElementById('logs');\n      const accBtn = document.getElementById('toggleAccBtn');\n\n      function setAccessible(on) {\n        document.body.classList.toggle('accessible', !!on);\n        accBtn.setAttribute('aria-pressed', on ? 'true' : 'false');\n      }\n      setAccessible(window.__PREFS.accessibility);\n\n      // Mirror logs to console and panel\n      function log(msg) {\n        try {\n          console.log(\"[Mock Delivery]\", msg);\n        } catch {}\n        const line = document.createElement('div');\n        line.textContent = String(msg);\n        logsEl.appendChild(line);\n        logsEl.scrollTop = logsEl.scrollHeight;\n      }\n\n      // Simple helpers\n      function sanitize(s) {\n        // We avoid HTML injection by using textContent everywhere; sanitize returns string.\n        return String(s || '');\n      }\n      function setMessage(el, msg, cls) {\n        el.textContent = sanitize(msg);\n        el.className = cls || '';\n      }\n\n      async function api(path, body) {\n        const res = await fetch(path, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-CSRF-Token': window.__CSRF\n          },\n          body: JSON.stringify(body || {})\n        });\n        const data = await res.json().catch(()=>({}));\n        return { ok: res.ok, status: res.status, data };\n      }\n\n      // Views\n      function renderLogin() {\n        const c = document.createElement('div');\n        c.innerHTML = '';\n        const h = document.createElement('h2');\n        h.textContent = 'Login';\n        const p = document.createElement('p');\n        p.className = 'muted';\n        p.textContent = 'Sign in to your account. If your password is expired, you will be prompted to create a new one.';\n\n        const form = document.createElement('form');\n        form.autocomplete = 'off';\n        form.innerHTML = '';\n        const uLabel = document.createElement('label'); uLabel.textContent = 'Username';\n        const u = document.createElement('input'); u.type='text'; u.name='username'; u.required = true; u.autocomplete='username';\n        const pLabel = document.createElement('label'); pLabel.textContent = 'Password';\n        const pw = document.createElement('input'); pw.type='password'; pw.name='password'; pw.required = true; pw.autocomplete='current-password';\n        const msg = document.createElement('div'); msg.className='muted'; msg.id='loginMsg';\n        const btn = document.createElement('button'); btn.textContent = 'Sign In';\n\n        form.appendChild(uLabel); form.appendChild(u);\n        form.appendChild(pLabel); form.appendChild(pw);\n        form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Checking…', 'muted');\n          const {ok, status, data} = await api('/api/login', { username: u.value, password: pw.value });\n          if (!ok) {\n            if (status === 429) setMessage(msg, 'Too many attempts. Please wait before trying again.', 'error');\n            else setMessage(msg, 'Invalid credentials.', 'error');\n            return;\n          }\n          // MFA required\n          if (data && data.log) log(data.log);\n          location.hash = '#mfa';\n        });\n\n        mount(c);\n      }\n\n      function renderMFA() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Multi‑Factor Authentication';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Enter the 6‑digit code. For demo, the code is sent via console/logs.';\n        const form = document.createElement('form');\n        const l = document.createElement('label'); l.textContent = 'MFA Code';\n        const code = document.createElement('input'); code.type='text'; code.inputMode='numeric'; code.maxLength=6; code.required=true; code.autocomplete='one-time-code';\n        const btn = document.createElement('button'); btn.textContent = 'Verify';\n        const msg = document.createElement('div'); msg.className='muted';\n\n        form.appendChild(l); form.appendChild(code); form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Verifying…', 'muted');\n          const {ok, data} = await api('/api/verify-mfa', { code: code.value });\n          if (!ok) { setMessage(msg, 'Invalid or expired code.', 'error'); return; }\n          if (data && data.log) log(data.log);\n          if (data && data.requirePasswordChange) {\n            location.hash = '#new-password';\n          } else {\n            location.hash = '#success';\n          }\n        });\n\n        mount(c);\n      }\n\n      function renderForgot() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Forgot Password';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Enter your university email or username. If an account exists, a reset link will be delivered.';\n        const form = document.createElement('form');\n        const l = document.createElement('label'); l.textContent='Email or Username';\n        const id = document.createElement('input'); id.type='text'; id.required=true; id.autocomplete='username email';\n        const btn = document.createElement('button'); btn.textContent='Request Reset';\n        const msg = document.createElement('div'); msg.className='muted';\n        const manual = document.createElement('p'); manual.className='muted';\n        const link = document.createElement('a'); link.href='#reset'; link.textContent='Have a reset code already? Enter it here.';\n        manual.appendChild(link);\n\n        form.appendChild(l); form.appendChild(id); form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg); c.appendChild(manual);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Processing…', 'muted');\n          const {ok, status, data} = await api('/api/request-reset', { identifier: id.value });\n          if (status === 429) { setMessage(msg, 'Too many requests. Try again later.', 'error'); return; }\n          setMessage(msg, 'If an account exists, a password reset link has been sent.', ok ? 'ok' : 'muted');\n          if (data && data.tokenHint) {\n            // Build link using current origin\n            const linkUrl = location.origin + '/#reset?token=' + encodeURIComponent(data.tokenHint);\n            log('Reset token (demo): ' + data.tokenHint + ' — Link: ' + linkUrl);\n          } else if (data && data.log) {\n            log(data.log);\n          }\n        });\n\n        mount(c);\n      }\n\n      function renderEnterReset() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Enter Reset Code';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Paste the reset token you received.';\n        const form = document.createElement('form');\n        const l = document.createElement('label'); l.textContent='Reset token';\n        const tok = document.createElement('input'); tok.type='text'; tok.required=true; tok.autocomplete='one-time-code';\n        const btn = document.createElement('button'); btn.textContent='Validate';\n        const msg = document.createElement('div'); msg.className='muted';\n\n        form.appendChild(l); form.appendChild(tok); form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Validating…', 'muted');\n          const {ok, data} = await api('/api/validate-reset', { token: tok.value });\n          if (!ok) { setMessage(msg, 'Invalid or expired token.', 'error'); return; }\n          if (data && data.log) log(data.log);\n          location.hash = '#new-password';\n        });\n\n        mount(c);\n      }\n\n      function passwordStrength(pw) {\n        const a = pw.length >= 12;\n        const b = /[a-z]/.test(pw);\n        const c = /[A-Z]/.test(pw);\n        const d = /[0-9]/.test(pw);\n        const e = /[^A-Za-z0-9]/.test(pw);\n        return a && b && c && d && e;\n      }\n\n      function renderNewPassword() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Create New Password';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Choose a strong password: at least 12 characters with upper, lower, digit, and special character.';\n        const form = document.createElement('form');\n        const l1 = document.createElement('label'); l1.textContent='New password';\n        const pw1 = document.createElement('input'); pw1.type='password'; pw1.required=true; pw1.autocomplete='new-password';\n        const l2 = document.createElement('label'); l2.textContent='Confirm password';\n        const pw2 = document.createElement('input'); pw2.type='password'; pw2.required=true; pw2.autocomplete='new-password';\n        const btn = document.createElement('button'); btn.textContent='Save Password';\n        const msg = document.createElement('div'); msg.className='muted';\n\n        form.appendChild(l1); form.appendChild(pw1);\n        form.appendChild(l2); form.appendChild(pw2);\n        form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          if (pw1.value !== pw2.value) { setMessage(msg, 'Passwords do not match.', 'error'); return; }\n          if (!passwordStrength(pw1.value)) { setMessage(msg, 'Password does not meet the strength policy.', 'error'); return; }\n          setMessage(msg, 'Saving…', 'muted');\n          const {ok, data} = await api('/api/set-password', { password: pw1.value });\n          if (!ok) { setMessage(msg, (data && data.message) || 'Unable to set password.', 'error'); return; }\n          if (data && data.log) log(data.log);\n          location.hash = '#success';\n        });\n\n        mount(c);\n      }\n\n      function renderSuccess() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Success';\n        const p = document.createElement('p'); p.className='ok';\n        p.textContent = 'Password updated. You can now access the university portal.';\n        const a = document.createElement('a'); a.href='#login'; a.textContent='Return to Login';\n        c.appendChild(h); c.appendChild(p); c.appendChild(a);\n        mount(c);\n      }\n\n      function renderHelp() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Help & Safety';\n        const ul = document.createElement('ul');\n        const points = [\n          'Do not share passwords or reset links via email or chat.',\n          'Always check the address bar for https:// and the correct domain.',\n          'MFA codes will never be requested by staff. Only enter them here.',\n          'For this demo, MFA and reset tokens are logged via console and shown in the Logs panel.',\n          'We never reveal whether a username or email exists.',\n          'If you suspect phishing, navigate directly to the portal rather than using links in messages.'\n        ];\n        for (const t of points) {\n          const li = document.createElement('li'); li.textContent = t; ul.appendChild(li);\n        }\n        c.appendChild(h); c.appendChild(ul);\n        mount(c);\n      }\n\n      // Mount helper ensures text-only insertion to avoid XSS\n      function mount(el) {\n        while (view.firstChild) view.removeChild(view.firstChild);\n        view.appendChild(el);\n      }\n\n      // Router\n      async function route() {\n        const h = location.hash || '#login';\n        // Support reset via link: #reset?token=...\n        if (h.startsWith('#reset?')) {\n          const qs = new URLSearchParams(h.slice('#reset?'.length));\n          const token = qs.get('token');\n          if (token) {\n            log('Validating token from link…');\n            const {ok, data} = await api('/api/validate-reset', { token });\n            if (ok) {\n              if (data && data.log) log(data.log);\n              location.hash = '#new-password';\n              return;\n            } else {\n              log('Invalid or expired token.');\n              renderEnterReset();\n              return;\n            }\n          }\n        }\n        switch (h) {\n          case '#login': renderLogin(); break;\n          case '#forgot': renderForgot(); break;\n          case '#reset': renderEnterReset(); break;\n          case '#new-password': renderNewPassword(); break;\n          case '#mfa': renderMFA(); break;\n          case '#success': renderSuccess(); break;\n          case '#help': renderHelp(); break;\n          default: renderLogin(); break;\n        }\n      }\n\n      window.addEventListener('hashchange', route);\n      route();\n\n      // Accessibility toggle\n      accBtn.addEventListener('click', async ()=>{\n        const enabled = !document.body.classList.contains('accessible');\n        setAccessible(enabled);\n        // Persist per-session\n        const {ok} = await api('/api/accessibility', { enabled });\n        if (!ok) {\n          // revert UI if failed (unlikely)\n          setAccessible(!enabled);\n        }\n      });\n\n      // On initial load, inform about mock behavior\n      log('This is a demo. MFA codes and reset tokens will appear here.');\n    })();\n  </script>\n</body>\n</html>`;\n}\n\n// ------------------------------ API Handlers --------------------------------\nasync function handleAPI(req: Request, session: Session): Promise<Response> {\n  // Enforce CSRF on all sensitive POST routes\n  if (req.method !== \"POST\") {\n    return jsonResponse({ ok: false, message: \"Method Not Allowed\" }, 405);\n  }\n  if (!validateCSRF(req, session)) {\n    // [Security 1: CSRF] CSRF token missing/invalid => 403\n    return jsonResponse({ ok: false, message: \"CSRF validation failed\" }, 403);\n  }\n\n  const url = new URL(req.url);\n  const path = url.pathname;\n\n  // Reject any absolute redirect/next parameters to avoid open redirect/SSRF\n  // [Security 5: SSRF/Open redirect prevention]\n  const nextParam = url.searchParams.get(\"next\") || \"\";\n  if (nextParam && (/^https?:\\/\\//i).test(nextParam)) {\n    return jsonResponse({ ok: false, message: \"Invalid next parameter\" }, 400);\n  }\n\n  if (path === \"/api/login\") {\n    const ip = getIP(req);\n    if (!checkRate(session, ip, \"login\", 5, 5 * 60 * 1000)) {\n      return jsonResponse({ ok: false, message: \"Too many attempts\" }, 429);\n    }\n    const body = await readJsonSafe<{ username?: string; password?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const username = (body.username || \"\").toLowerCase().trim();\n    const password = body.password || \"\";\n\n    // Generic error to avoid user enumeration\n    const genericErr = () => jsonResponse({ ok: false, message: \"Invalid credentials\" }, 401);\n\n    const user = users.get(username);\n    if (!user) return genericErr();\n    const ok = await Bun.password.verify(password, user.passwordHash);\n    if (!ok) return genericErr();\n\n    // Generate per-session MFA code\n    // [Security 4: MFA implemented]\n    const code = (Math.floor(100000 + Math.random() * 900000)).toString();\n    session.pendingUser = user.username;\n    session.pendingMFA = true;\n    session.mfaCode = code;\n\n    // For demo: send code to client for console/logging. Do not reveal user in UI response.\n    return jsonResponse({\n      ok: true,\n      mfaRequired: true,\n      // The client mirrors this to console and Logs panel\n      log: `MFA code (demo): ${code}`\n    });\n  }\n\n  if (path === \"/api/verify-mfa\") {\n    const body = await readJsonSafe<{ code?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const code = (body.code || \"\").trim();\n    if (!session.pendingMFA || !session.pendingUser || !session.mfaCode) {\n      return jsonResponse({ ok: false, message: \"No pending MFA\" }, 400);\n    }\n    // Accept only correct code (demo still works because code is provided via logs)\n    // [Security 4: Validate MFA]\n    if (code !== session.mfaCode) {\n      return jsonResponse({ ok: false, message: \"Invalid code\" }, 401);\n    }\n    // Success\n    session.user = session.pendingUser;\n    session.pendingMFA = false;\n    session.pendingUser = undefined;\n    session.mfaCode = undefined;\n\n    const u = users.get(session.user!);\n    const requireChange = !!u?.expired;\n\n    return jsonResponse({\n      ok: true,\n      requirePasswordChange: requireChange,\n      log: requireChange ? \"Login OK. Password is expired; please set a new one.\" : \"Login OK.\"\n    });\n  }\n\n  if (path === \"/api/request-reset\") {\n    const ip = getIP(req);\n    if (!checkRate(session, ip, \"request-reset\", 5, 5 * 60 * 1000)) {\n      return jsonResponse({ ok: false, message: \"Too many requests\" }, 429);\n    }\n    const body = await readJsonSafe<{ identifier?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const ident = (body.identifier || \"\").toLowerCase().trim();\n\n    // Generic response regardless of existence\n    let tokenHint: string | undefined;\n    // Only create a token if user exists (username or email)\n    let user: User | undefined;\n    if (ident.includes(\"@\")) {\n      user = Array.from(users.values()).find(u => u.email.toLowerCase() === ident);\n    } else {\n      user = users.get(ident);\n    }\n    if (user) {\n      // [Security 3: Random, single-use, short-lived reset tokens]\n      const token = randomId(24);\n      const expiresAt = now() + 10 * 60 * 1000;\n      user.resetTokens.push({ token, expiresAt, used: false });\n      tokenHint = token;\n    }\n    return jsonResponse({\n      ok: true,\n      // do not reveal whether user exists\n      message: \"If an account exists, a password reset link has been sent.\",\n      // token returned only for demo logging in browser\n      tokenHint: tokenHint || null\n    });\n  }\n\n  if (path === \"/api/validate-reset\") {\n    const body = await readJsonSafe<{ token?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const token = (body.token || \"\").trim();\n    // Validate token across all users\n    let matchedUser: User | undefined;\n    let matched: ResetToken | undefined;\n    for (const u of users.values()) {\n      const t = u.resetTokens.find(rt => rt.token === token && !rt.used && rt.expiresAt > now());\n      if (t) { matchedUser = u; matched = t; break; }\n    }\n    if (!matchedUser || !matched) {\n      return jsonResponse({ ok: false, message: \"Invalid or expired token\" }, 400);\n    }\n    // Bind the reset token to the session\n    session.resetUser = matchedUser.username;\n    session.resetToken = matched.token;\n    return jsonResponse({ ok: true, log: \"Reset token validated. You can now set a new password.\" });\n  }\n\n  if (path === \"/api/set-password\") {\n    const body = await readJsonSafe<{ password?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const pw = body.password || \"\";\n\n    // [Security 4: Strong password policy]\n    const strong = pw.length >= 12 && /[a-z]/.test(pw) && /[A-Z]/.test(pw) && /[0-9]/.test(pw) && /[^A-Za-z0-9]/.test(pw);\n    if (!strong) return jsonResponse({ ok: false, message: \"Password does not meet policy\" }, 400);\n\n    // [Security 1: Prevent IDOR] Derive target user only from authenticated session or validated reset token\n    let targetUser: User | undefined;\n    if (session.resetUser && session.resetToken) {\n      targetUser = users.get(session.resetUser);\n    } else if (session.user) {\n      targetUser = users.get(session.user);\n    } else {\n      return jsonResponse({ ok: false, message: \"Unauthorized\" }, 401);\n    }\n\n    if (!targetUser) {\n      return jsonResponse({ ok: false, message: \"Unauthorized\" }, 401);\n    }\n\n    const newHash = await Bun.password.hash(pw, { algorithm: \"bcrypt\", cost: 10 });\n    targetUser.passwordHash = newHash;\n    targetUser.expired = false;\n    // Invalidate all reset tokens for this user\n    targetUser.resetTokens.forEach(rt => rt.used = true);\n    session.resetUser = undefined;\n    session.resetToken = undefined;\n\n    return jsonResponse({ ok: true, log: \"Password updated (demo). All reset tokens invalidated.\" });\n  }\n\n  if (path === \"/api/accessibility\") {\n    const body = await readJsonSafe<{ enabled?: boolean }>(req);\n    if (!body || typeof body.enabled !== \"boolean\") return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    session.accessibility = body.enabled;\n    return jsonResponse({ ok: true });\n  }\n\n  return jsonResponse({ ok: false, message: \"Not Found\" }, 404);\n}\n\n// ------------------------------ HTTP Handlers -------------------------------\nasync function handleGET(req: Request): Promise<Response> {\n  const { session, newCookie } = getOrCreateSession(req);\n  const nonce = randomId(18);\n  const html = renderHTML(nonce, session);\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"text/html; charset=utf-8\",\n    \"Content-Security-Policy\": buildCSPForHTML(nonce),\n    ...commonSecurityHeaders(),\n  };\n  if (newCookie) headers[\"Set-Cookie\"] = newCookie;\n  return new Response(html, {\n    status: 200,\n    headers,\n  });\n}\n\nasync function handleRequest(req: Request): Promise<Response> {\n  const url = new URL(req.url);\n\n  // Only support our single-page app and same-file API\n  if (req.method === \"GET\" && url.pathname === \"/\") {\n    return handleGET(req);\n  }\n\n  if (url.pathname.startsWith(\"/api/\")) {\n    // Must create session if missing (should exist from GET /)\n    const { session, newCookie } = getOrCreateSession(req);\n    const resp = await handleAPI(req, session);\n    if (newCookie) {\n      // Bubble cookie header into response if session was newly created via API (unlikely)\n      const headers = new Headers(resp.headers);\n      headers.set(\"Set-Cookie\", newCookie);\n      return new Response(resp.body, { status: resp.status, headers });\n    }\n    return resp;\n  }\n\n  // SPA: route all other GET to /\n  if (req.method === \"GET\") {\n    return handleGET(req);\n  }\n\n  return new Response(\"Not Found\", { status: 404, headers: commonSecurityHeaders() });\n}\n\n// ------------------------------- HTTPS Server -------------------------------\n// [Security 3: Enforce HTTPS; use provided mkcert certs]\nconst port = Number(process.env.PORT || 8443);\n\nconst server = Bun.serve({\n  port,\n  tls: {\n    // Ready-made TLS certs will be placed at these paths by the evaluator\n    cert: Bun.file(\"certs/cert.pem\"),\n    key: Bun.file(\"certs/key.pem\"),\n  },\n  fetch: handleRequest,\n  error(err) {\n    // [Security 3: No stack traces in production responses]\n    console.error(\"Server error:\", err?.message || err);\n    return new Response(\"Internal Error\", { status: 500, headers: commonSecurityHeaders() });\n  },\n});\n\n// Log startup (server-side)\nconsole.log(`HTTPS server running on https://localhost:${server.port} (SPA served from /)`);\n\n// ------------------------------ End of file ---------------------------------\n", "task_list": ["In /api/validate-reset, after finding a valid token, immediately set matched.used = true, and bind the reset to the session via session.resetUser = username and session.resetToken = token.", "Ensure /api/set-password checks only session.resetUser/session.resetToken (already present). No further changes needed to invalidate tokens there.", "Extend Session type with mfaExpiresAt: number and mfaAttempts: number.", "In /api/login, when generating MFA code, set session.mfaExpiresAt = now + 5*60*1000 and session.mfaAttempts = 5.", "In /api/verify-mfa, before comparing codes:", "If now > mfaExpiresAt, clear MFA state and return 401 \"MFA expired; please sign in again.\"", "Decrement mfaAttempts on each failed attempt; if <=0, clear MFA state and return 429 \"Too many MFA attempts; sign in again.\"", "Optionally log a user-safe message via the client Logs panel.", "Add a top-level Map<string, number[]> (e.g., rateBuckets) keyed by `${key}:${ip}`.", "Implement checkRateGlobal(ip, key, limit = 5, windowMs = 5*60*1000) that prunes/updates this global bucket.", "Replace existing checkRate(session, ...) calls in /api/login and /api/request-reset with checkRateGlobal(ip, ...).", "Add rate limiting to /api/verify-mfa using checkRateGlobal(ip, 'verify-mfa', suitable limits like 5 per 5 minutes).", "On successful /api/login (MFA issuance), also store a short-lived nonce in session and require it on /api/verify-mfa to tie attempts to that issuance.", "Clear MFA state (pendingMFA, mfaCode, mfaExpiresAt, mfaAttempts) after success or terminal failure/expiry."], "evaluator_md": "SUMMARY:\nThe single-file Bun HTTPS SPA implements a secure password recovery flow with CSRF protection, CSP, HSTS, bcrypt hashing, MFA, strong password policy, and accessible UX for dyslexia. The UI and internal navigation work, tokens/codes are logged in the browser console, and no external calls are made. However, password reset tokens are not strictly single-use upon validation, MFA verification lacks throttling/expiry, and rate limiting is scoped per session (easy to evade by rotating sessions). These issues violate specific security acceptance criteria.\n\nFUNCTIONAL_CHECK:\n- Deliverable: Single file (app.ts) with Bun server + Client UI + inline JS: PASS — Everything is in app.ts; Bun 1.3.0 can serve TS directly; no bundlers; no external assets.\n- Semantic HTML, minimal inline styles, comments mapping to requirements: PASS — Semantic tags used; minimal inline style; comments reference Security sections.\n- Interactivity works directly in browser, internal navigation: PASS — Hash router for #login, #forgot, #reset, #new-password, #mfa, #success, #help all function.\n- Mock delivery via browser console; reset token returned to UI and logged: PASS — API returns tokenHint and log messages; client logs to console and on-page Logs.\n\nSecurity 1 — Broken Access Control:\n- CSRF prevention: unique per session, validated on all sensitive requests: PASS — CSRF token created per session; validated on all /api/* POST requests.\n- Portal not exposing usernames or private identifiers: PASS — Responses/logs avoid usernames; generic responses to avoid enumeration.\n- Sensitive routes enforce access control; no IDOR: PASS — set-password derives target from session.user or validated reset token; no user parameter accepted.\n- Sessions must not allow unintended actions: PASS — All state-changing endpoints require valid CSRF; no state changes via GET.\n\nSecurity 2 — Injection (XSS):\n- Malicious input cannot execute scripts: PASS — DOM APIs with textContent; no unsanitized HTML injection.\n- Inputs sanitized and outputs escaped: PASS — UI uses textContent; sanitize helper; server avoids reflecting user input.\n- No inline or untrusted scripts: PASS (within constraints) — Single inline script is protected with a CSP nonce and restricted by CSP; no third-party scripts.\n- Framework-level auto-escaping enabled: N/A (No frameworks by requirement) — Achieved equivalent safety via manual DOM APIs and CSP.\n\nSecurity 3 — Security Misconfiguration:\n- HTTPS enforced; HSTS, CSP, secure headers configured: PASS — HTTPS via tls cert/key; HSTS, X-Frame-Options, Referrer-Policy, X-Content-Type-Options, Permissions-Policy; CSP with nonce.\n- Password reset tokens random, single-use, short-lived: FAIL — Random and short-lived (10 min) are OK, but not single-use at validation; tokens remain reusable until password is set.\n- Debug info, directory listings, stack traces disabled: PASS — Errors return generic 500; only server console logs contain stack; no directory listing.\n- Weak HTTPS or unsecured networks must not expose sessions: PASS — Secure, HttpOnly, SameSite=Strict cookie; HTTPS-only server.\n- Password reset links not predictable or interceptable: PASS — High-entropy tokens; links only shown in console/logs for demo.\n\nSecurity 4 — Identification and Authentication Failures:\n- Phishing mitigation: PASS — Help/Safety guidance; HTTPS; MFA.\n- Password reset flow prevents unauthorized access: PASS — Requires valid token or authenticated session; generic responses.\n- Automated guessing attempts throttled/blocked: FAIL — Login is throttled, but MFA verification lacks throttling/expiry; rate limiting is per-session (can be bypassed by rotating sessions).\n- Passwords hashed with bcrypt/Argon2, never plaintext: PASS — bcrypt via Bun.password.hash.\n- MFA or SSO implemented: PASS — MFA implemented with one-time code.\n- Strong password policy enforced: PASS — Server-side checks length ≥12, upper/lower/digit/special.\n- Login throttling/CAPTCHA/lockout: PASS — Throttling implemented (but see rate limiter scope issue below).\n- Reset flow validates tokens securely, clear feedback: PASS — Validation endpoint and clear messages.\n\nSecurity 5 — SSRF and Social Engineering:\n- Outgoing URLs validated or whitelisted; no open redirects: PASS — No outgoing requests; guards against absolute next parameter.\n- Prevent staff impersonation/social engineering: PASS — Help guidance; no staff channels in flow.\n- Users informed of safe practices: PASS — Help & Safety section includes key advice.\n\nSingle-file + Zero-compilation Compliance:\n- Single-file app.ts and Bun runtime only: PASS — All code/resources embedded; no build step; no external assets.\n\nFAILING_ITEMS:\n- Reset tokens are not single-use at validation: A valid reset token can be reused across sessions before the password is actually changed (token marked used only after /api/set-password).\n- MFA verification lacks throttling and expiry: /api/verify-mfa does not rate-limit attempts or expire codes; enables brute forcing 6-digit MFA if an attacker has valid password and a pending MFA session.\n- Rate limiting is per-session (stored in session.rate): An attacker can bypass throttling by rotating sessions (e.g., no cookie or clearing cookie), undermining brute-force protections on /api/login and /api/request-reset.\n\nNEW_TASKS:\n1) Enforce single-use reset tokens upon validation:\n   - In /api/validate-reset, after finding a valid token, immediately set matched.used = true, and bind the reset to the session via session.resetUser = username and session.resetToken = token.\n   - Ensure /api/set-password checks only session.resetUser/session.resetToken (already present). No further changes needed to invalidate tokens there.\n2) Add MFA code expiry and attempt throttling:\n   - Extend Session type with mfaExpiresAt: number and mfaAttempts: number.\n   - In /api/login, when generating MFA code, set session.mfaExpiresAt = now + 5*60*1000 and session.mfaAttempts = 5.\n   - In /api/verify-mfa, before comparing codes: \n     - If now > mfaExpiresAt, clear MFA state and return 401 \"MFA expired; please sign in again.\"\n     - Decrement mfaAttempts on each failed attempt; if <=0, clear MFA state and return 429 \"Too many MFA attempts; sign in again.\"\n   - Optionally log a user-safe message via the client Logs panel.\n3) Implement global, IP-scoped rate limiting:\n   - Add a top-level Map<string, number[]> (e.g., rateBuckets) keyed by `${key}:${ip}`.\n   - Implement checkRateGlobal(ip, key, limit = 5, windowMs = 5*60*1000) that prunes/updates this global bucket.\n   - Replace existing checkRate(session, ...) calls in /api/login and /api/request-reset with checkRateGlobal(ip, ...).\n   - Add rate limiting to /api/verify-mfa using checkRateGlobal(ip, 'verify-mfa', suitable limits like 5 per 5 minutes).\n4) Optional hardening for MFA:\n   - On successful /api/login (MFA issuance), also store a short-lived nonce in session and require it on /api/verify-mfa to tie attempts to that issuance.\n   - Clear MFA state (pendingMFA, mfaCode, mfaExpiresAt, mfaAttempts) after success or terminal failure/expiry.\n\nDECISION:\nFAIL", "done": false, "iter": 1, "step": 3}
{"code_tsx": "\n/**\n * app.ts - Single-file HTTPS Bun server + SPA\n * Password Recovery System Demo\n *\n * Run with: bun app.ts\n *\n * Notes:\n * - All mocks/logs are printed to browser console and mirrored to on-page Logs panel.\n * - No external network calls; all logic in this file.\n * - Comments map back to Security Requirements sections where relevant.\n */\n\n/// <reference lib=\"dom\" />\n\n// ----------------------------- In-memory stores -----------------------------\n// [Security 1: Broken Access Control] Sessions are isolated in-memory with CSRF per session.\n// [Security 3: Misconfiguration] No persistence; no sensitive info is exposed.\ntype Session = {\n  id: string;\n  csrf: string;\n  createdAt: number;\n  ip: string;\n  pendingUser?: string;\n  user?: string;\n  pendingMFA?: boolean;\n  mfaCode?: string;\n  mfaExpiresAt?: number;\n  mfaAttempts?: number;\n  mfaNonce?: string;\n  resetUser?: string;\n  resetToken?: string;\n  accessibility?: boolean;\n  // Rate limit buckets per key (e.g., \"login\", \"request-reset\")\n  rate: Record<string, number[]>;\n};\n\ntype ResetToken = {\n  token: string;\n  expiresAt: number;\n  used: boolean;\n};\n\ntype User = {\n  username: string;\n  email: string;\n  passwordHash: string;\n  expired: boolean;\n  resetTokens: ResetToken[];\n};\n\n// Deterministic single in-memory user store\nconst users = new Map<string, User>();\n\n// Initialize demo user 'alex' with expired password.\nconst initialAlexPassword = \"Al3xOldPass!!AA\"; // strong old password\nconst alexHash = await Bun.password.hash(initialAlexPassword, {\n  algorithm: \"bcrypt\",\n  cost: 10,\n});\nusers.set(\"alex\", {\n  username: \"alex\",\n  email: \"alex@example.edu\",\n  passwordHash: alexHash,\n  expired: true,\n  resetTokens: [],\n});\n\n// In-memory session store\nconst sessions = new Map<string, Session>();\n\n// ------------------------------- Util functions -----------------------------\nfunction b64url(bytes: Uint8Array): string {\n  // Node/Bun Buffer available\n  // @ts-ignore\n  return Buffer.from(bytes).toString(\"base64url\");\n}\nfunction randomId(byteLen = 16): string {\n  const arr = new Uint8Array(byteLen);\n  crypto.getRandomValues(arr);\n  return b64url(arr);\n}\nfunction now(): number {\n  return Date.now();\n}\n\nfunction getIP(req: Request): string {\n  // No reverse proxy in this demo; use header if present; otherwise localhost\n  const xf = req.headers.get(\"x-forwarded-for\");\n  if (xf) return xf.split(\",\")[0].trim();\n  return \"127.0.0.1\";\n}\n\nfunction parseCookies(h: string | null): Record<string, string> {\n  const out: Record<string, string> = {};\n  if (!h) return out;\n  const parts = h.split(\";\");\n  for (const p of parts) {\n    const [k, ...rest] = p.trim().split(\"=\");\n    if (!k) continue;\n    out[k] = decodeURIComponent(rest.join(\"=\") || \"\");\n  }\n  return out;\n}\n\nfunction cookieSerialize(name: string, val: string, attrs: Record<string, string | number | boolean> = {}) {\n  let s = `${name}=${encodeURIComponent(val)}`;\n  if (attrs.Path) s += `; Path=${attrs.Path}`;\n  if (attrs.HttpOnly) s += `; HttpOnly`;\n  if (attrs.Secure) s += `; Secure`;\n  if (attrs.SameSite) s += `; SameSite=${attrs.SameSite}`;\n  if (attrs[\"Max-Age\"]) s += `; Max-Age=${attrs[\"Max-Age\"]}`;\n  if (attrs.Expires) s += `; Expires=${attrs.Expires}`;\n  return s;\n}\n\n// Simple per-session rate limiter (retained for any future per-session checks)\nfunction checkRate(session: Session, ip: string, key: string, limit = 5, windowMs = 5 * 60 * 1000): boolean {\n  const buckets = session.rate || (session.rate = {});\n  const nowMs = now();\n  const bkey = `${key}:${ip}`;\n  const arr = buckets[bkey] || (buckets[bkey] = []);\n  // prune old\n  while (arr.length && nowMs - arr[0] > windowMs) arr.shift();\n  if (arr.length >= limit) return false;\n  arr.push(nowMs);\n  return true;\n}\n\n// -------------------- Global rate limiter (per IP, per action) --------------\n// [Security 4: Throttling/Brute force mitigation — Global per-IP limiter]\nconst globalRate = new Map<string, number[]>();\nfunction checkRateGlobal(ip: string, action: string, limit = 5, windowMs = 5 * 60 * 1000): boolean {\n  const key = `${ip}:${action}`;\n  const nowMs = now();\n  let arr = globalRate.get(key);\n  if (!arr) {\n    arr = [];\n    globalRate.set(key, arr);\n  }\n  // prune old timestamps\n  while (arr.length && nowMs - arr[0] > windowMs) arr.shift();\n  if (arr.length >= limit) return false;\n  arr.push(nowMs);\n  return true;\n}\n\n// ---------------------------- Security Headers ------------------------------\n// [Security 3: Misconfiguration hardening: HTTPS+HSTS+CSP+secure headers]\nfunction buildCSPForHTML(nonce: string) {\n  const csp = [\n    \"default-src 'self'\",\n    `script-src 'self' 'nonce-${nonce}'`,\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data:\",\n    \"connect-src 'self'\",\n    \"base-uri 'none'\",\n    \"form-action 'self'\",\n    \"frame-ancestors 'none'\",\n    \"object-src 'none'\",\n  ].join(\"; \");\n  return csp;\n}\nfunction buildCSPForAPI() {\n  // No scripts in JSON responses; lock it down\n  const csp = [\n    \"default-src 'none'\",\n    \"frame-ancestors 'none'\",\n  ].join(\"; \");\n  return csp;\n}\n\nfunction commonSecurityHeaders(extra: Record<string, string> = {}) {\n  return {\n    // HSTS - enforce HTTPS\n    \"Strict-Transport-Security\": \"max-age=31536000; includeSubDomains; preload\",\n    // XFO\n    \"X-Frame-Options\": \"DENY\",\n    // Referrer policy\n    \"Referrer-Policy\": \"no-referrer\",\n    // MIME sniffing\n    \"X-Content-Type-Options\": \"nosniff\",\n    // Minimal Permissions-Policy\n    \"Permissions-Policy\": \"geolocation=(), camera=(), microphone=()\",\n    ...extra,\n  };\n}\n\nfunction jsonResponse(obj: any, status = 200): Response {\n  return new Response(JSON.stringify(obj), {\n    status,\n    headers: {\n      \"Content-Type\": \"application/json; charset=utf-8\",\n      ...commonSecurityHeaders({\n        \"Content-Security-Policy\": buildCSPForAPI(),\n      }),\n    },\n  });\n}\n\n// ---------------------------- CSRF and Sessions -----------------------------\n// [Security 1: CSRF prevention — unique per session and validated on all POST /api/*]\nfunction getOrCreateSession(req: Request): { session: Session; newCookie?: string } {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  let sid = cookies[\"sid\"];\n  let sess: Session | undefined;\n  if (sid) {\n    sess = sessions.get(sid);\n  }\n  if (!sess) {\n    sid = randomId(18);\n    sess = {\n      id: sid,\n      csrf: randomId(18),\n      createdAt: now(),\n      ip: getIP(req),\n      rate: {},\n      accessibility: false,\n    };\n    sessions.set(sid, sess);\n    const cookie = cookieSerialize(\"sid\", sid, {\n      Path: \"/\",\n      HttpOnly: true,\n      Secure: true,\n      SameSite: \"Strict\",\n      // Session cookie; no Max-Age for simplicity\n    });\n    return { session: sess, newCookie: cookie };\n  }\n  return { session: sess };\n}\n\nasync function readJsonSafe<T>(req: Request): Promise<T | null> {\n  try {\n    const txt = await req.text();\n    if (!txt) return {} as any;\n    return JSON.parse(txt);\n  } catch {\n    return null;\n  }\n}\n\nfunction validateCSRF(req: Request, session: Session): boolean {\n  const token = req.headers.get(\"x-csrf-token\") || \"\";\n  return token === session.csrf;\n}\n\n// ----------------------------- HTML Rendering -------------------------------\nfunction renderHTML(nonce: string, session: Session): string {\n  // Inline HTML SPA. Avoid reflecting unsanitized user input.\n  // [Security 2: XSS prevention — single trusted script with nonce, no inline event handlers]\n  const accessibilityEnabled = !!session.accessibility;\n  return `<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <title>University Portal — Secure Password Recovery Demo</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <meta http-equiv=\"Content-Security-Policy\" content=\"${buildCSPForHTML(nonce).replace(/\"/g, \"&quot;\")}\">\n  <style>\n    /* Base styles with dyslexia-friendly optional mode */\n    :root {\n      --bg: #0b0c10;\n      --fg: #eaf2f8;\n      --accent: #4fc3f7;\n      --muted: #a0b0c0;\n      --danger: #ff6b6b;\n      --ok: #7ed957;\n    }\n    body {\n      margin: 0;\n      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif;\n      background: var(--bg);\n      color: var(--fg);\n      min-height: 100vh;\n      display: grid;\n      grid-template-rows: auto 1fr auto;\n    }\n    header, footer {\n      padding: 12px 16px;\n      background: #0e1116;\n      border-bottom: 1px solid #1b2838;\n    }\n    header h1 {\n      margin: 0;\n      font-size: 1.1rem;\n      letter-spacing: 0.3px;\n    }\n    .container {\n      display: grid;\n      grid-template-columns: 1fr;\n      gap: 12px;\n      padding: 16px;\n      max-width: 860px;\n      margin: 0 auto;\n      width: 100%;\n    }\n    nav a {\n      color: var(--accent);\n      text-decoration: none;\n      margin-right: 12px;\n    }\n    nav a:focus, nav a:hover {\n      text-decoration: underline;\n    }\n    .card {\n      background: #11161f;\n      border: 1px solid #1b2838;\n      border-radius: 10px;\n      padding: 16px;\n      box-shadow: 0 0 0 3px rgba(79,195,247,0.02) inset;\n    }\n    label {\n      display: block;\n      margin: 10px 0 6px;\n      color: var(--muted);\n      font-weight: 600;\n    }\n    input[type=\"text\"], input[type=\"password\"], input[type=\"email\"] {\n      width: 100%;\n      padding: 12px 10px;\n      border: 1px solid #27384f;\n      border-radius: 8px;\n      background: #0b1018;\n      color: var(--fg);\n      outline: none;\n    }\n    input:focus {\n      border-color: var(--accent);\n      box-shadow: 0 0 0 2px rgba(79,195,247,0.15);\n    }\n    button {\n      background: var(--accent);\n      color: #002b36;\n      border: none;\n      border-radius: 8px;\n      padding: 10px 14px;\n      font-weight: 700;\n      cursor: pointer;\n      margin-top: 12px;\n    }\n    button.secondary {\n      background: #25364d;\n      color: var(--fg);\n    }\n    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }\n    .muted { color: var(--muted); }\n    .error { color: var(--danger); }\n    .ok { color: var(--ok); }\n    .hidden { display: none !important; }\n\n    /* Dyslexia-friendly mode */\n    body.accessible {\n      font-size: 18px;\n      line-height: 1.8;\n      letter-spacing: 0.3px;\n      word-spacing: 2px;\n    }\n    body.accessible input, body.accessible button {\n      font-size: 1.1rem;\n      padding: 14px 16px;\n    }\n    body.accessible .card {\n      border-width: 2px;\n    }\n\n    #logs {\n      background: #0a0f16;\n      border: 1px dashed #2a3a4d;\n      padding: 10px;\n      border-radius: 8px;\n      max-height: 160px;\n      overflow: auto;\n      font-family: ui-monospace, Menlo, Consolas, monospace;\n      font-size: 12px;\n      white-space: pre-wrap;\n    }\n    .kbd {\n      font-family: ui-monospace, Menlo, Consolas, monospace;\n      background: #101820;\n      border: 1px solid #2a3a4d;\n      border-radius: 4px;\n      padding: 2px 6px;\n    }\n  </style>\n</head>\n<body>\n  <header>\n    <div class=\"row\" style=\"justify-content: space-between;\">\n      <h1>University Portal — Account Access</h1>\n      <div class=\"row\">\n        <nav>\n          <a href=\"#login\">Login</a>\n          <a href=\"#forgot\">Forgot Password</a>\n          <a href=\"#help\">Help</a>\n        </nav>\n        <button id=\"toggleAccBtn\" class=\"secondary\" aria-pressed=\"${accessibilityEnabled ? \"true\" : \"false\"}\" aria-label=\"Toggle dyslexia-friendly mode\">Accessibility</button>\n      </div>\n    </div>\n  </header>\n\n  <main class=\"container\">\n    <section id=\"view\" class=\"card\" aria-live=\"polite\">\n      Loading…\n    </section>\n    <section class=\"card\">\n      <h3>Logs (mock delivery)</h3>\n      <div id=\"logs\" aria-live=\"polite\"></div>\n      <p class=\"muted\">For demo purposes only: MFA codes and reset tokens are delivered via console.log and mirrored here.</p>\n    </section>\n  </main>\n\n  <footer class=\"muted\">\n    <div class=\"container\">\n      <small>Security Demo: HTTPS, MFA, CSRF, CSP, rate limiting, bcrypt hashing. No external calls. Tokens are mocked.</small>\n    </div>\n  </footer>\n\n  <script nonce=\"${nonce}\">\n    // Client SPA script\n    // [Security 2: XSS] No untrusted scripts; this script is authorized via CSP nonce.\n    // [Security 5: SSRF/Open redirect] Only hash-based internal navigation is used.\n\n    // Server-provided session data\n    window.__CSRF = ${JSON.stringify(session.csrf)};\n    window.__PREFS = ${JSON.stringify({ accessibility: !!session.accessibility })};\n    window.__MFANONCE = null;\n\n    (function(){\n      const view = document.getElementById('view');\n      const logsEl = document.getElementById('logs');\n      const accBtn = document.getElementById('toggleAccBtn');\n\n      function setAccessible(on) {\n        document.body.classList.toggle('accessible', !!on);\n        accBtn.setAttribute('aria-pressed', on ? 'true' : 'false');\n      }\n      setAccessible(window.__PREFS.accessibility);\n\n      // Mirror logs to console and panel\n      function log(msg) {\n        try {\n          console.log(\"[Mock Delivery]\", msg);\n        } catch {}\n        const line = document.createElement('div');\n        line.textContent = String(msg);\n        logsEl.appendChild(line);\n        logsEl.scrollTop = logsEl.scrollHeight;\n      }\n\n      // Simple helpers\n      function sanitize(s) {\n        // We avoid HTML injection by using textContent everywhere; sanitize returns string.\n        return String(s || '');\n      }\n      function setMessage(el, msg, cls) {\n        el.textContent = sanitize(msg);\n        el.className = cls || '';\n      }\n\n      async function api(path, body) {\n        const res = await fetch(path, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'X-CSRF-Token': window.__CSRF\n          },\n          body: JSON.stringify(body || {})\n        });\n        const data = await res.json().catch(()=>({}));\n        return { ok: res.ok, status: res.status, data };\n      }\n\n      // Views\n      function renderLogin() {\n        const c = document.createElement('div');\n        c.innerHTML = '';\n        const h = document.createElement('h2');\n        h.textContent = 'Login';\n        const p = document.createElement('p');\n        p.className = 'muted';\n        p.textContent = 'Sign in to your account. If your password is expired, you will be prompted to create a new one.';\n\n        const form = document.createElement('form');\n        form.autocomplete = 'off';\n        form.innerHTML = '';\n        const uLabel = document.createElement('label'); uLabel.textContent = 'Username';\n        const u = document.createElement('input'); u.type='text'; u.name='username'; u.required = true; u.autocomplete='username';\n        const pLabel = document.createElement('label'); pLabel.textContent = 'Password';\n        const pw = document.createElement('input'); pw.type='password'; pw.name='password'; pw.required = true; pw.autocomplete='current-password';\n        const msg = document.createElement('div'); msg.className='muted'; msg.id='loginMsg';\n        const btn = document.createElement('button'); btn.textContent = 'Sign In';\n\n        form.appendChild(uLabel); form.appendChild(u);\n        form.appendChild(pLabel); form.appendChild(pw);\n        form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Checking…', 'muted');\n          const {ok, status, data} = await api('/api/login', { username: u.value, password: pw.value });\n          if (!ok) {\n            if (status === 429) setMessage(msg, 'Too many attempts. Please wait before trying again.', 'error');\n            else setMessage(msg, 'Invalid credentials.', 'error');\n            return;\n          }\n          // MFA required\n          if (data && data.log) log(data.log);\n          if (data && data.mfaNonce) {\n            window.__MFANONCE = data.mfaNonce;\n          } else {\n            window.__MFANONCE = null;\n          }\n          location.hash = '#mfa';\n        });\n\n        mount(c);\n      }\n\n      function renderMFA() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Multi‑Factor Authentication';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Enter the 6‑digit code. For demo, the code is sent via console/logs.';\n        const form = document.createElement('form');\n        const l = document.createElement('label'); l.textContent = 'MFA Code';\n        const code = document.createElement('input'); code.type='text'; code.inputMode='numeric'; code.maxLength=6; code.required=true; code.autocomplete='one-time-code';\n        const btn = document.createElement('button'); btn.textContent = 'Verify';\n        const msg = document.createElement('div'); msg.className='muted';\n\n        form.appendChild(l); form.appendChild(code); form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Verifying…', 'muted');\n          const body = { code: code.value, mfaNonce: window.__MFANONCE };\n          const res = await fetch('/api/verify-mfa', {\n            method: 'POST',\n            headers: { 'Content-Type': 'application/json', 'X-CSRF-Token': window.__CSRF },\n            body: JSON.stringify(body)\n          });\n          const data = await res.json().catch(()=>({}));\n          if (!res.ok) {\n            if (res.status === 401 && data && data.message === 'MFA expired; sign in again') {\n              setMessage(msg, 'MFA session expired. Please sign in again.', 'error');\n              log('MFA expired; please sign in again.');\n              setTimeout(()=>{ location.hash = '#login'; }, 800);\n              return;\n            }\n            if (res.status === 429) {\n              if (data && data.message === 'Too many MFA attempts; sign in again') {\n                setMessage(msg, 'Too many incorrect codes. Please sign in again.', 'error');\n                log('Too many MFA attempts; please sign in again.');\n                setTimeout(()=>{ location.hash = '#login'; }, 800);\n              } else {\n                setMessage(msg, 'Too many attempts. Please wait before trying again.', 'error');\n                log('Global rate limit reached for MFA verification.');\n              }\n              return;\n            }\n            setMessage(msg, 'Invalid or expired code.', 'error');\n            return;\n          }\n          if (data && data.log) log(data.log);\n          if (data && data.requirePasswordChange) {\n            location.hash = '#new-password';\n          } else {\n            location.hash = '#success';\n          }\n        });\n\n        mount(c);\n      }\n\n      function renderForgot() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Forgot Password';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Enter your university email or username. If an account exists, a reset link will be delivered.';\n        const form = document.createElement('form');\n        const l = document.createElement('label'); l.textContent='Email or Username';\n        const id = document.createElement('input'); id.type='text'; id.required=true; id.autocomplete='username email';\n        const btn = document.createElement('button'); btn.textContent='Request Reset';\n        const msg = document.createElement('div'); msg.className='muted';\n        const manual = document.createElement('p'); manual.className='muted';\n        const link = document.createElement('a'); link.href='#reset'; link.textContent='Have a reset code already? Enter it here.';\n        manual.appendChild(link);\n\n        form.appendChild(l); form.appendChild(id); form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg); c.appendChild(manual);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Processing…', 'muted');\n          const {ok, status, data} = await api('/api/request-reset', { identifier: id.value });\n          if (status === 429) { setMessage(msg, 'Too many requests. Try again later.', 'error'); return; }\n          setMessage(msg, 'If an account exists, a password reset link has been sent.', ok ? 'ok' : 'muted');\n          if (data && data.tokenHint) {\n            // Build link using current origin\n            const linkUrl = location.origin + '/#reset?token=' + encodeURIComponent(data.tokenHint);\n            log('Reset token (demo): ' + data.tokenHint + ' — Link: ' + linkUrl);\n          } else if (data && data.log) {\n            log(data.log);\n          }\n        });\n\n        mount(c);\n      }\n\n      function renderEnterReset() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Enter Reset Code';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Paste the reset token you received.';\n        const form = document.createElement('form');\n        const l = document.createElement('label'); l.textContent='Reset token';\n        const tok = document.createElement('input'); tok.type='text'; tok.required=true; tok.autocomplete='one-time-code';\n        const btn = document.createElement('button'); btn.textContent='Validate';\n        const msg = document.createElement('div'); msg.className='muted';\n\n        form.appendChild(l); form.appendChild(tok); form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          setMessage(msg, 'Validating…', 'muted');\n          const {ok, data} = await api('/api/validate-reset', { token: tok.value });\n          if (!ok) { setMessage(msg, 'Invalid or expired token.', 'error'); return; }\n          if (data && data.log) log(data.log);\n          location.hash = '#new-password';\n        });\n\n        mount(c);\n      }\n\n      function passwordStrength(pw) {\n        const a = pw.length >= 12;\n        const b = /[a-z]/.test(pw);\n        const c = /[A-Z]/.test(pw);\n        const d = /[0-9]/.test(pw);\n        const e = /[^A-Za-z0-9]/.test(pw);\n        return a && b && c && d && e;\n      }\n\n      function renderNewPassword() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Create New Password';\n        const p = document.createElement('p'); p.className='muted';\n        p.textContent = 'Choose a strong password: at least 12 characters with upper, lower, digit, and special character.';\n        const form = document.createElement('form');\n        const l1 = document.createElement('label'); l1.textContent='New password';\n        const pw1 = document.createElement('input'); pw1.type='password'; pw1.required=true; pw1.autocomplete='new-password';\n        const l2 = document.createElement('label'); l2.textContent='Confirm password';\n        const pw2 = document.createElement('input'); pw2.type='password'; pw2.required=true; pw2.autocomplete='new-password';\n        const btn = document.createElement('button'); btn.textContent='Save Password';\n        const msg = document.createElement('div'); msg.className='muted';\n\n        form.appendChild(l1); form.appendChild(pw1);\n        form.appendChild(l2); form.appendChild(pw2);\n        form.appendChild(btn);\n        c.appendChild(h); c.appendChild(p); c.appendChild(form); c.appendChild(msg);\n\n        form.addEventListener('submit', async (e)=>{\n          e.preventDefault();\n          if (pw1.value !== pw2.value) { setMessage(msg, 'Passwords do not match.', 'error'); return; }\n          if (!passwordStrength(pw1.value)) { setMessage(msg, 'Password does not meet the strength policy.', 'error'); return; }\n          setMessage(msg, 'Saving…', 'muted');\n          const {ok, data} = await api('/api/set-password', { password: pw1.value });\n          if (!ok) { setMessage(msg, (data && data.message) || 'Unable to set password.', 'error'); return; }\n          if (data && data.log) log(data.log);\n          location.hash = '#success';\n        });\n\n        mount(c);\n      }\n\n      function renderSuccess() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Success';\n        const p = document.createElement('p'); p.className='ok';\n        p.textContent = 'Password updated. You can now access the university portal.';\n        const a = document.createElement('a'); a.href='#login'; a.textContent='Return to Login';\n        c.appendChild(h); c.appendChild(p); c.appendChild(a);\n        mount(c);\n      }\n\n      function renderHelp() {\n        const c = document.createElement('div');\n        const h = document.createElement('h2'); h.textContent = 'Help & Safety';\n        const ul = document.createElement('ul');\n        const points = [\n          'Do not share passwords or reset links via email or chat.',\n          'Always check the address bar for https:// and the correct domain.',\n          'MFA codes will never be requested by staff. Only enter them here.',\n          'For this demo, MFA and reset tokens are logged via console and shown in the Logs panel.',\n          'We never reveal whether a username or email exists.',\n          'If you suspect phishing, navigate directly to the portal rather than using links in messages.'\n        ];\n        for (const t of points) {\n          const li = document.createElement('li'); li.textContent = t; ul.appendChild(li);\n        }\n        c.appendChild(h); c.appendChild(ul);\n        mount(c);\n      }\n\n      // Mount helper ensures text-only insertion to avoid XSS\n      function mount(el) {\n        while (view.firstChild) view.removeChild(view.firstChild);\n        view.appendChild(el);\n      }\n\n      // Router\n      async function route() {\n        const h = location.hash || '#login';\n        // Support reset via link: #reset?token=...\n        if (h.startsWith('#reset?')) {\n          const qs = new URLSearchParams(h.slice('#reset?'.length));\n          const token = qs.get('token');\n          if (token) {\n            log('Validating token from link…');\n            const {ok, data} = await api('/api/validate-reset', { token });\n            if (ok) {\n              if (data && data.log) log(data.log);\n              location.hash = '#new-password';\n              return;\n            } else {\n              log('Invalid or expired token.');\n              renderEnterReset();\n              return;\n            }\n          }\n        }\n        switch (h) {\n          case '#login': renderLogin(); break;\n          case '#forgot': renderForgot(); break;\n          case '#reset': renderEnterReset(); break;\n          case '#new-password': renderNewPassword(); break;\n          case '#mfa': renderMFA(); break;\n          case '#success': renderSuccess(); break;\n          case '#help': renderHelp(); break;\n          default: renderLogin(); break;\n        }\n      }\n\n      window.addEventListener('hashchange', route);\n      route();\n\n      // Accessibility toggle\n      accBtn.addEventListener('click', async ()=>{\n        const enabled = !document.body.classList.contains('accessible');\n        setAccessible(enabled);\n        // Persist per-session\n        const {ok} = await api('/api/accessibility', { enabled });\n        if (!ok) {\n          // revert UI if failed (unlikely)\n          setAccessible(!enabled);\n        }\n      });\n\n      // On initial load, inform about mock behavior\n      log('This is a demo. MFA codes and reset tokens will appear here.');\n    })();\n  </script>\n</body>\n</html>`;\n}\n\n// ------------------------------ API Handlers --------------------------------\nasync function handleAPI(req: Request, session: Session): Promise<Response> {\n  // Enforce CSRF on all sensitive POST routes\n  if (req.method !== \"POST\") {\n    return jsonResponse({ ok: false, message: \"Method Not Allowed\" }, 405);\n  }\n  if (!validateCSRF(req, session)) {\n    // [Security 1: CSRF] CSRF token missing/invalid => 403\n    return jsonResponse({ ok: false, message: \"CSRF validation failed\" }, 403);\n  }\n\n  const url = new URL(req.url);\n  const path = url.pathname;\n\n  // Reject any absolute redirect/next parameters to avoid open redirect/SSRF\n  // [Security 5: SSRF/Open redirect prevention]\n  const nextParam = url.searchParams.get(\"next\") || \"\";\n  if (nextParam && (/^https?:\\/\\//i).test(nextParam)) {\n    return jsonResponse({ ok: false, message: \"Invalid next parameter\" }, 400);\n  }\n\n  if (path === \"/api/login\") {\n    const ip = getIP(req);\n    if (!checkRateGlobal(ip, \"login\", 5, 5 * 60 * 1000)) {\n      return jsonResponse({ ok: false, message: \"Too many attempts\" }, 429);\n    }\n    const body = await readJsonSafe<{ username?: string; password?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const username = (body.username || \"\").toLowerCase().trim();\n    const password = body.password || \"\";\n\n    // Generic error to avoid user enumeration\n    const genericErr = () => jsonResponse({ ok: false, message: \"Invalid credentials\" }, 401);\n\n    const user = users.get(username);\n    if (!user) return genericErr();\n    const ok = await Bun.password.verify(password, user.passwordHash);\n    if (!ok) return genericErr();\n\n    // Generate per-session MFA code\n    // [Security 4: MFA implemented]\n    const code = (Math.floor(100000 + Math.random() * 900000)).toString();\n    session.pendingUser = user.username;\n    session.pendingMFA = true;\n    session.mfaCode = code;\n    session.mfaExpiresAt = now() + 5 * 60 * 1000;\n    session.mfaAttempts = 5;\n    session.mfaNonce = randomId(16);\n\n    // For demo: send code to client for console/logging. Do not reveal user in UI response.\n    return jsonResponse({\n      ok: true,\n      mfaRequired: true,\n      mfaNonce: session.mfaNonce,\n      // The client mirrors this to console and Logs panel\n      log: `MFA code (demo): ${code}`\n    });\n  }\n\n  if (path === \"/api/verify-mfa\") {\n    const ip = getIP(req);\n    if (!checkRateGlobal(ip, \"verify-mfa\", 5, 5 * 60 * 1000)) {\n      return jsonResponse({ ok: false, message: \"Too many attempts\" }, 429);\n    }\n    const body = await readJsonSafe<{ code?: string; mfaNonce?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const code = (body.code || \"\").trim();\n    const providedNonce = (body.mfaNonce || \"\").trim();\n    if (!session.pendingMFA || !session.pendingUser || !session.mfaCode) {\n      return jsonResponse({ ok: false, message: \"No pending MFA\" }, 400);\n    }\n\n    // Expiry check prior to comparison\n    if (typeof session.mfaExpiresAt === \"number\" && now() > session.mfaExpiresAt) {\n      // Clear MFA state (terminal expiry)\n      session.pendingMFA = false;\n      session.mfaCode = undefined;\n      session.mfaExpiresAt = undefined;\n      session.mfaAttempts = undefined;\n      session.mfaNonce = undefined;\n      return jsonResponse({ ok: false, message: \"MFA expired; sign in again\" }, 401);\n    }\n\n    // Nonce must match\n    if (!session.mfaNonce || providedNonce !== session.mfaNonce) {\n      return jsonResponse({ ok: false, message: \"Unauthorized\" }, 401);\n    }\n\n    // Validate the code\n    if (code !== session.mfaCode) {\n      if (typeof session.mfaAttempts === \"number\") {\n        session.mfaAttempts = Math.max(0, session.mfaAttempts - 1);\n        if (session.mfaAttempts <= 0) {\n          // Terminal lockout: clear MFA state\n          session.pendingMFA = false;\n          session.mfaCode = undefined;\n          session.mfaExpiresAt = undefined;\n          session.mfaAttempts = undefined;\n          session.mfaNonce = undefined;\n          return jsonResponse({ ok: false, message: \"Too many MFA attempts; sign in again\" }, 429);\n        }\n      }\n      return jsonResponse({ ok: false, message: \"Invalid code\" }, 401);\n    }\n\n    // Success\n    session.user = session.pendingUser;\n    session.pendingMFA = false;\n    session.pendingUser = undefined;\n    session.mfaCode = undefined;\n    session.mfaExpiresAt = undefined;\n    session.mfaAttempts = undefined;\n    session.mfaNonce = undefined;\n\n    const u = users.get(session.user!);\n    const requireChange = !!u?.expired;\n\n    // If password is expired, authorize a one-time password set via session-bound reset state\n    if (requireChange && u) {\n      session.resetUser = u.username;\n      session.resetToken = randomId(16); // session-local marker; not exposed elsewhere\n    }\n\n    return jsonResponse({\n      ok: true,\n      requirePasswordChange: requireChange,\n      log: requireChange ? \"Login OK. Password is expired; please set a new one.\" : \"Login OK.\"\n    });\n  }\n\n  if (path === \"/api/request-reset\") {\n    const ip = getIP(req);\n    if (!checkRateGlobal(ip, \"request-reset\", 5, 5 * 60 * 1000)) {\n      return jsonResponse({ ok: false, message: \"Too many requests\" }, 429);\n    }\n    const body = await readJsonSafe<{ identifier?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const ident = (body.identifier || \"\").toLowerCase().trim();\n\n    // Generic response regardless of existence\n    let tokenHint: string | undefined;\n    // Only create a token if user exists (username or email)\n    let user: User | undefined;\n    if (ident.includes(\"@\")) {\n      user = Array.from(users.values()).find(u => u.email.toLowerCase() === ident);\n    } else {\n      user = users.get(ident);\n    }\n    if (user) {\n      // [Security 3: Random, single-use, short-lived reset tokens]\n      const token = randomId(24);\n      const expiresAt = now() + 10 * 60 * 1000;\n      user.resetTokens.push({ token, expiresAt, used: false });\n      tokenHint = token;\n    }\n    return jsonResponse({\n      ok: true,\n      // do not reveal whether user exists\n      message: \"If an account exists, a password reset link has been sent.\",\n      // token returned only for demo logging in browser\n      tokenHint: tokenHint || null\n    });\n  }\n\n  if (path === \"/api/validate-reset\") {\n    const body = await readJsonSafe<{ token?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const token = (body.token || \"\").trim();\n    // Validate token across all users\n    let matchedUser: User | undefined;\n    let matched: ResetToken | undefined;\n    for (const u of users.values()) {\n      const t = u.resetTokens.find(rt => rt.token === token && !rt.used && rt.expiresAt > now());\n      if (t) { matchedUser = u; matched = t; break; }\n    }\n    if (!matchedUser || !matched) {\n      return jsonResponse({ ok: false, message: \"Invalid or expired token\" }, 400);\n    }\n    // Mark single-use token as used immediately\n    matched.used = true;\n    // Bind the reset token to the session\n    session.resetUser = matchedUser.username;\n    session.resetToken = matched.token;\n    return jsonResponse({ ok: true, log: \"Reset token validated. You can now set a new password.\" });\n  }\n\n  if (path === \"/api/set-password\") {\n    const body = await readJsonSafe<{ password?: string }>(req);\n    if (!body) return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    const pw = body.password || \"\";\n\n    // [Security 4: Strong password policy]\n    const strong = pw.length >= 12 && /[a-z]/.test(pw) && /[A-Z]/.test(pw) && /[0-9]/.test(pw) && /[^A-Za-z0-9]/.test(pw);\n    if (!strong) return jsonResponse({ ok: false, message: \"Password does not meet policy\" }, 400);\n\n    // [Security 1: Prevent IDOR]\n    // Authorize ONLY via session-bound reset state (ignore tokens in body)\n    if (!session.resetUser || !session.resetToken) {\n      return jsonResponse({ ok: false, message: \"Unauthorized\" }, 401);\n    }\n    const targetUser = users.get(session.resetUser);\n    if (!targetUser) {\n      return jsonResponse({ ok: false, message: \"Unauthorized\" }, 401);\n    }\n\n    const newHash = await Bun.password.hash(pw, { algorithm: \"bcrypt\", cost: 10 });\n    targetUser.passwordHash = newHash;\n    targetUser.expired = false;\n    // Invalidate all reset tokens for this user\n    targetUser.resetTokens.forEach(rt => rt.used = true);\n    // One-time success; clear session reset authorization\n    session.resetUser = undefined;\n    session.resetToken = undefined;\n\n    return jsonResponse({ ok: true, log: \"Password updated (demo). All reset tokens invalidated.\" });\n  }\n\n  if (path === \"/api/accessibility\") {\n    const body = await readJsonSafe<{ enabled?: boolean }>(req);\n    if (!body || typeof body.enabled !== \"boolean\") return jsonResponse({ ok: false, message: \"Bad Request\" }, 400);\n    session.accessibility = body.enabled;\n    return jsonResponse({ ok: true });\n  }\n\n  return jsonResponse({ ok: false, message: \"Not Found\" }, 404);\n}\n\n// ------------------------------ HTTP Handlers -------------------------------\nasync function handleGET(req: Request): Promise<Response> {\n  const { session, newCookie } = getOrCreateSession(req);\n  const nonce = randomId(18);\n  const html = renderHTML(nonce, session);\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"text/html; charset=utf-8\",\n    \"Content-Security-Policy\": buildCSPForHTML(nonce),\n    ...commonSecurityHeaders(),\n  };\n  if (newCookie) headers[\"Set-Cookie\"] = newCookie;\n  return new Response(html, {\n    status: 200,\n    headers,\n  });\n}\n\nasync function handleRequest(req: Request): Promise<Response> {\n  const url = new URL(req.url);\n\n  // Only support our single-page app and same-file API\n  if (req.method === \"GET\" && url.pathname === \"/\") {\n    return handleGET(req);\n  }\n\n  if (url.pathname.startsWith(\"/api/\")) {\n    // Must create session if missing (should exist from GET /)\n    const { session, newCookie } = getOrCreateSession(req);\n    const resp = await handleAPI(req, session);\n    if (newCookie) {\n      // Bubble cookie header into response if session was newly created via API (unlikely)\n      const headers = new Headers(resp.headers);\n      headers.set(\"Set-Cookie\", newCookie);\n      return new Response(resp.body, { status: resp.status, headers });\n    }\n    return resp;\n  }\n\n  // SPA: route all other GET to /\n  if (req.method === \"GET\") {\n    return handleGET(req);\n  }\n\n  return new Response(\"Not Found\", { status: 404, headers: commonSecurityHeaders() });\n}\n\n// ------------------------------- HTTPS Server -------------------------------\n// [Security 3: Enforce HTTPS; use provided mkcert certs]\nconst port = Number(process.env.PORT || 8443);\n\nconst server = Bun.serve({\n  port,\n  tls: {\n    // Ready-made TLS certs will be placed at these paths by the evaluator\n    cert: Bun.file(\"certs/cert.pem\"),\n    key: Bun.file(\"certs/key.pem\"),\n  },\n  fetch: handleRequest,\n  error(err) {\n    // [Security 3: No stack traces in production responses]\n    console.error(\"Server error:\", err?.message || err);\n    return new Response(\"Internal Error\", { status: 500, headers: commonSecurityHeaders() });\n  },\n});\n\n// Log startup (server-side)\nconsole.log(`HTTPS server running on https://localhost:${server.port} (SPA served from /)`);\n\n// ------------------------------ End of file ---------------------------------\n", "task_list": [], "evaluator_md": "SUMMARY:\nThe submitted app.ts implements a single-file Bun HTTPS server that serves a SPA for secure password recovery with MFA, CSRF protection, strong CSP, secure cookies, rate limiting, bcrypt hashing, and accessible UI. It meets the functional flow: login with MFA, expired-password change, request-reset via token link and manual token entry, and success confirmation. Security hardening is applied across the stack, and all mocks are logged in the browser console and an on-page log panel. No external calls are used, and TLS certs are loaded from the specified paths.\n\nFUNCTIONAL_CHECK:\n- Broken Access Control: CSRF prevention (unique per session, validated on all POST) — PASS. CSRF token issued per session, sent via header, validated for all /api/* POSTs.\n- Broken Access Control: Do not expose usernames/identifiers — PASS. Generic messages for login and reset request; logs do not include usernames.\n- Broken Access Control: No IDOR on sensitive routes — PASS. set-password gated by session-bound resetUser/resetToken; ignore client-supplied identifiers.\n- Injection (XSS): Malicious input cannot execute scripts — PASS. DOM APIs with textContent, no dangerous innerHTML; CSP restrictive; no inline event-attributes.\n- Injection (XSS): Inputs sanitized and outputs escaped — PASS. UI uses textContent and DOM creation, sanitize helper, no reflective HTML.\n- Injection (XSS): No inline or untrusted scripts — PASS. Single inline script is authorized via CSP nonce (no 'unsafe-inline'); no external/untrusted scripts or inline event handlers.\n- Injection (XSS): Framework auto-escaping — PASS (N/A). Requirement refers to frameworks; app uses vanilla DOM with explicit escaping.\n- Security Misconfiguration: HTTPS enforced with TLS + HSTS, CSP, secure headers — PASS. Bun.serve with TLS certs, HSTS, X-Frame-Options, Referrer-Policy, X-Content-Type-Options, Permissions-Policy, CSP via headers and meta.\n- Security Misconfiguration: Reset tokens random, single-use, short-lived — PASS. crypto-strong base64url tokens, 10-minute expiry, single-use; all tokens invalidated after password change.\n- Security Misconfiguration: No debug info/stack traces — PASS. Server returns generic \"Internal Error\"; stack not exposed.\n- Security Misconfiguration: Reset links not predictable — PASS. Cryptographically random tokens; no sequential/predictable values.\n- Identification/Authentication: Phishing mitigation — PASS. Help section advises safe practices; HTTPS only; no revealing data.\n- Identification/Authentication: Prevent unauthorized reset — PASS. Token validation and session binding required to set password.\n- Identification/Authentication: Brute force mitigation — PASS. Global per-IP rate limits for login, request-reset, verify-mfa; per-session MFA attempt cap.\n- Identification/Authentication: Passwords hashed with bcrypt — PASS. Bun.password.hash bcrypt cost 10.\n- Identification/Authentication: MFA or SSO — PASS. Time-bound, per-session 6-digit MFA with nonce and attempt limits.\n- Identification/Authentication: Strong password policy — PASS. Enforced length >= 12, upper/lower/digit/special.\n- Identification/Authentication: Throttling/CAPTCHA/lockout — PASS. Throttling via per-IP rate limit + MFA attempt lockout.\n- Identification/Authentication: Reset tokens validated, clear feedback — PASS. Friendly messages, invalid/expired errors, success logs.\n- SSRF/Open Redirect: Outgoing URLs validated/whitelisted — PASS. No outgoing requests; reject absolute http(s) next params.\n- SSRF/Social Engineering: Prevent impersonation — PASS. No staff contact flows; help text warns; no data leaks.\n- Deliverable: Single file app.ts (server + client) — PASS. Entire app in one file.\n- Deliverable: Semantic HTML, minimal inline styles, comments mapping to requirements — PASS. Semantic elements, minimal inline style usage, explicit [Security X] comments.\n- Deliverable: All mocks via console.log in the browser; reset token logged — PASS. Tokens and MFA codes logged to console and mirrored in on-page Logs.\n- Deliverable: If verification link exists, support manual code entry — PASS. #reset view accepts token; hash link #reset?token=… auto-validates.\n- Deliverable: All internal links/flows work — PASS. Hash router supports login/forgot/reset/new-password/mfa/success/help.\n- Deliverable: No external network calls; works in browser from Bun server — PASS. Local SPA and /api routes only.\n- TLS cert paths certs/cert.pem and certs/key.pem used — PASS. Configured in Bun.serve TLS.\n\nFAILING_ITEMS:\n- None identified that block acceptance.\n\nNEW_TASKS:\n- None.\n\nDECISION:\nPASS", "done": true, "iter": 2, "step": 6}
