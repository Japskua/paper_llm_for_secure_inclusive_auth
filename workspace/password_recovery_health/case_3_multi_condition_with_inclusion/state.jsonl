{"code_tsx": "\n/**\n * app.ts - Single-file HTTPS Bun server + SPA for Password Recovery System\n * Run with: bun app.ts\n *\n * This file implements:\n * - HTTPS server with TLS (certs/cert.pem, certs/key.pem)\n * - Strict security headers (HSTS, CSP with nonce, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy)\n * - In-memory stores for users, sessions, CSRF tokens, password reset tokens, MFA codes, and rate limiting\n * - SPA HTML with inline CSS/JS using CSP nonce (no inline event handlers)\n * - Client-side hash routing for: login, request reset, verify token, set new password, MFA verify, and success\n * - API endpoints for request-reset, verify-token, set-password, login, mfa-verify\n * - Strong password policy checks (client + server), bcrypt/argon2id hashing via Bun.password.hash\n * - Anti-CSRF on all sensitive POST routes\n * - Rate limiting on sensitive POST routes\n * - Input sanitization and escaping helpers (server + client)\n * - Logs panel mirroring console.log and \"For demo\" panel showing mock deliveries\n *\n * Security Comments map to \"Security Evaluation Requirements\" where relevant in code blocks below.\n */\n\ntype User = {\n  id: string;\n  username: string;\n  email: string;\n  passwordHash: string; // argon2id\n  mfaEnabled: boolean;\n};\n\ntype Session = {\n  id: string;\n  csrf: string;\n  createdAt: number;\n  lastSeenAt: number;\n  ip?: string;\n  canSetPassword?: boolean;\n  resetUserId?: string | null;\n  mfaPending?: boolean;\n  mfaCode?: string | null;\n  mfaGeneratedAt?: number | null;\n  authenticated?: boolean;\n  // simple progress hints for inclusivity (pause/resume)\n  lastView?: string;\n};\n\ntype ResetToken = {\n  token: string; // random base64url\n  code: string; // human 6-digit\n  userId: string | null;\n  createdAt: number;\n  expiresAt: number;\n  used: boolean;\n  sessionId?: string;\n};\n\ntype RateRecord = {\n  count: number;\n  last: number;\n  blockedUntil: number;\n};\n\nconst users = new Map<string, User>();\nconst sessions = new Map<string, Session>();\nconst resetTokens = new Map<string, ResetToken>(); // key: token\nconst rateMap = new Map<string, RateRecord>();\n\n// Utility: base64url encode\nfunction b64url(buf: Uint8Array): string {\n  const b64 = Buffer.from(buf).toString(\"base64\");\n  return b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\n\nfunction randomId(bytes = 32): string {\n  return b64url(crypto.getRandomValues(new Uint8Array(bytes)));\n}\n\nfunction now(): number {\n  return Date.now();\n}\n\nfunction escapeHTML(s: string): string {\n  return s\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\");\n}\n\nfunction sanitizeInput(input: unknown, maxLen = 256): string {\n  let s = String(input ?? \"\");\n  s = s.replace(/[\\u0000-\\u001F\\u007F]/g, \"\"); // strip control chars\n  s = s.replace(/\\s+/g, \" \").trim();\n  s = s.slice(0, maxLen);\n  return s;\n}\n\nfunction parseCookies(header: string | null): Record<string, string> {\n  const obj: Record<string, string> = {};\n  if (!header) return obj;\n  header.split(\";\").forEach((p) => {\n    const [k, ...rest] = p.split(\"=\");\n    if (!k) return;\n    const key = k.trim();\n    const val = rest.join(\"=\").trim();\n    if (!key) return;\n    obj[key] = decodeURIComponent(val || \"\");\n  });\n  return obj;\n}\n\n// Security: CSRF token unique per session\nfunction ensureSession(req: Request, ip?: string): { session: Session; setCookies: string[] } {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  let sid = cookies[\"sid\"];\n  let session = sid ? sessions.get(sid) : undefined;\n  const setCookies: string[] = [];\n  if (!session) {\n    sid = randomId(32);\n    const csrf = randomId(16);\n    session = {\n      id: sid,\n      csrf,\n      createdAt: now(),\n      lastSeenAt: now(),\n      ip,\n      authenticated: false,\n      canSetPassword: false,\n      resetUserId: null,\n      mfaPending: false,\n      mfaCode: null,\n      mfaGeneratedAt: null,\n      lastView: \"login\",\n    };\n    sessions.set(sid, session);\n  } else {\n    session.lastSeenAt = now();\n    if (ip && !session.ip) session.ip = ip;\n  }\n  // Secure cookies\n  setCookies.push(\n    `sid=${encodeURIComponent(session.id)}; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=2592000`\n  );\n  // CSRF token cookie (HttpOnly) - readable only by server; we also embed token in HTML meta for client usage.\n  setCookies.push(\n    `csrf=${encodeURIComponent(session.csrf)}; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=2592000`\n  );\n  return { session, setCookies };\n}\n\nfunction securityHeaders(opts: { csp?: string; hsts?: boolean } = {}): HeadersInit {\n  const h: HeadersInit = {\n    \"X-Frame-Options\": \"DENY\",\n    \"X-Content-Type-Options\": \"nosniff\",\n    \"Referrer-Policy\": \"no-referrer\",\n    \"Permissions-Policy\":\n      \"accelerometer=(), camera=(), microphone=(), geolocation=(), gyroscope=(), magnetometer=(), payment=(), usb=()\",\n    \"Cache-Control\": \"no-store\",\n  };\n  if (opts.csp) (h as any)[\"Content-Security-Policy\"] = opts.csp;\n  if (opts.hsts !== false) {\n    (h as any)[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains; preload\";\n  }\n  return h;\n}\n\n// Security: Rate limiting per session+IP+route with exponential backoff\nfunction rateKey(session: Session, route: string, ip?: string) {\n  return `${session.id}|${ip || \"noip\"}|${route}`;\n}\nfunction rateLimitCheck(session: Session, route: string, ip?: string): { ok: boolean; headers?: HeadersInit; retryAfter?: number } {\n  const key = rateKey(session, route, ip);\n  const rec = rateMap.get(key) || { count: 0, last: 0, blockedUntil: 0 };\n  const t = now();\n  // decay count after 60 seconds\n  if (t - rec.last > 60_000) {\n    rec.count = 0;\n  }\n  rec.last = t;\n  if (t < rec.blockedUntil) {\n    const retryAfter = Math.ceil((rec.blockedUntil - t) / 1000);\n    return { ok: false, headers: { \"Retry-After\": String(retryAfter) }, retryAfter };\n  }\n  rec.count += 1;\n  if (rec.count > 5) {\n    const backoff = Math.min(120_000, 5_000 * Math.pow(2, rec.count - 6)); // exponential backoff\n    rec.blockedUntil = t + backoff;\n  }\n  rateMap.set(key, rec);\n  return { ok: true };\n}\n\nfunction jsonResponse(\n  body: any,\n  init: { status?: number; headers?: HeadersInit; csp?: string } = {}\n) {\n  const headers: HeadersInit = {\n    \"Content-Type\": \"application/json; charset=utf-8\",\n    ...(init.headers || {}),\n    ...securityHeaders({ csp: init.csp }),\n  };\n  return new Response(JSON.stringify(body), { status: init.status || 200, headers });\n}\n\nfunction badRequest(message = \"Bad Request\") {\n  return jsonResponse({ ok: false, message }, { status: 400 });\n}\nfunction forbidden(message = \"Forbidden\") {\n  return jsonResponse({ ok: false, message }, { status: 403 });\n}\n\n// Security: server-side CSRF validation\nasync function requireCsrf(req: Request, session: Session): Promise<boolean> {\n  const token = req.headers.get(\"x-csrf-token\") || \"\";\n  if (!token || token !== session.csrf) {\n    return false;\n  }\n  return true;\n}\n\n// Password policy (both client and server use same logic)\nfunction checkPasswordPolicy(pw: string): { ok: boolean; reasons: string[] } {\n  const reasons: string[] = [];\n  if (pw.length < 12) reasons.push(\"At least 12 characters\");\n  if (!/[a-z]/.test(pw)) reasons.push(\"Include lowercase letters\");\n  if (!/[A-Z]/.test(pw)) reasons.push(\"Include uppercase letters\");\n  if (!/[0-9]/.test(pw)) reasons.push(\"Include a number\");\n  if (!/[^\\w\\s]/.test(pw)) reasons.push(\"Include a symbol\");\n  if (/\\s/.test(pw)) reasons.push(\"No spaces allowed\");\n  return { ok: reasons.length === 0, reasons };\n}\n\n// Demo data: one user (avoid private identifiers in UI)\nconst DEMO_USER_ID = \"u1\";\nasync function initDemoUser() {\n  const hash = await Bun.password.hash(\"StrongPassw0rd!\", {\n    algorithm: \"argon2id\",\n    memoryCost: 19456,\n    timeCost: 2,\n  });\n  users.set(DEMO_USER_ID, {\n    id: DEMO_USER_ID,\n    username: \"helena\",\n    email: \"patient@example.com\",\n    passwordHash: hash,\n    mfaEnabled: true,\n  });\n}\n\nfunction deriveHumanCodeFromToken(token: string): string {\n  // deterministic 6-digit code from token hash\n  let acc = 0;\n  for (let i = 0; i < token.length; i++) {\n    acc = (acc * 31 + token.charCodeAt(i)) >>> 0;\n  }\n  const code = (acc % 1_000_000).toString().padStart(6, \"0\");\n  return code;\n}\n\nfunction generateResetToken(userId: string | null, sessionId: string): ResetToken {\n  const token = randomId(32);\n  const code = deriveHumanCodeFromToken(token);\n  const createdAt = now();\n  const expiresAt = createdAt + 15 * 60_000; // 15 minutes\n  const rt: ResetToken = { token, code, userId, createdAt, expiresAt, used: false, sessionId };\n  resetTokens.set(token, rt);\n  return rt;\n}\n\nfunction findTokenByCode(code: string): ResetToken | undefined {\n  let found: ResetToken | undefined;\n  for (const t of resetTokens.values()) {\n    if (t.code === code) {\n      // pick the most recent non-expired\n      if (!found || t.createdAt > found.createdAt) found = t;\n    }\n  }\n  return found;\n}\n\n// MFA generation: deterministic per-session when login succeeds\nfunction generateMfaForSession(session: Session): string {\n  const seed = session.id + \"|\" + session.csrf + \"|\" + session.createdAt;\n  let acc = 7;\n  for (let i = 0; i < seed.length; i++) acc = (acc * 33 + seed.charCodeAt(i)) >>> 0;\n  const code = (acc % 1_000_000).toString().padStart(6, \"0\");\n  session.mfaCode = code;\n  session.mfaPending = true;\n  session.mfaGeneratedAt = now();\n  return code;\n}\n\n// Build CSP per response\nfunction buildCSP(nonce: string): string {\n  // Security: CSP with nonce, disallow inline except our nonce, no external\n  return [\n    \"default-src 'self'\",\n    `script-src 'self' 'nonce-${nonce}'`,\n    `style-src 'self' 'nonce-${nonce}'`,\n    \"img-src 'self' data:\",\n    \"connect-src 'self'\",\n    \"font-src 'self'\",\n    \"object-src 'none'\",\n    \"base-uri 'none'\",\n    \"frame-ancestors 'none'\",\n    \"form-action 'self'\",\n  ].join(\"; \");\n}\n\n// Render SPA HTML (Security: outputs escaped; Inline JS/CSS via CSP nonce)\nfunction renderHTML(session: Session, nonce: string): string {\n  const csrf = escapeHTML(session.csrf);\n  const lastView = escapeHTML(session.lastView || \"login\");\n  // No user identifiers printed\n  return `<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <title>Hospital Account Access — Secure Recovery</title>\n  <meta id=\"csrf-meta\" data-token=\"${csrf}\">\n  <meta id=\"session-view\" data-last=\"${lastView}\">\n  <style nonce=\"${nonce}\">\n    /* Inclusivity & Accessibility (Requirements: Inclusivity) */\n    :root {\n      --bg: #f7fafc;\n      --fg: #1a202c;\n      --muted: #4a5568;\n      --primary: #2563eb;\n      --accent: #16a34a;\n      --warn: #b91c1c;\n      --card: #ffffff;\n      --focus: #f59e0b;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;\n      background: var(--bg); color: var(--fg);\n    }\n    header {\n      background: #0f172a; color: #fff; padding: 16px;\n    }\n    header h1 { margin: 0 0 4px 0; font-size: 20px; }\n    header p { margin: 0; color: #cbd5e1; font-size: 14px; }\n    main { max-width: 860px; margin: 24px auto; padding: 0 12px; }\n    .layout { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; }\n    @media (max-width: 900px) { .layout { grid-template-columns: 1fr; } }\n    .card {\n      background: var(--card); border-radius: 10px; padding: 16px;\n      box-shadow: 0 2px 6px rgba(0,0,0,0.06);\n    }\n    .step-header { display:flex; align-items:center; justify-content:space-between; margin-bottom: 12px; }\n    .progress { width: 100%; height: 8px; background: #e5e7eb; border-radius: 999px; overflow: hidden; margin-top: 8px; }\n    .progress > div { height: 100%; background: var(--primary); width: 0%; transition: width .3s; }\n    nav a { color: #bfdbfe; margin-right: 16px; text-decoration: none; }\n    nav a:focus { outline: 3px solid var(--focus); border-radius: 4px; }\n    h2 { margin: 0 0 8px 0; }\n    .muted { color: var(--muted); font-size: 14px; }\n    label { display:block; margin: 10px 0 6px; }\n    input[type=\"text\"], input[type=\"password\"] {\n      width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px;\n    }\n    button {\n      background: var(--primary); color: #fff; border: 0; padding: 10px 16px; border-radius: 8px; cursor: pointer;\n      margin-top: 12px; font-weight: 600;\n    }\n    button.secondary { background: #374151; }\n    button.link { background: transparent; color: var(--primary); text-decoration: underline; padding: 6px 4px; }\n    .row { display:flex; gap: 8px; align-items:center; }\n    .success { color: var(--accent); }\n    .error { color: var(--warn); }\n    .info { color: #1d4ed8; }\n    .sr { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }\n    .hidden { display: none !important; }\n\n    .panel { font-size: 12px; }\n    #logs { height: 180px; overflow: auto; background: #0b1020; color: #e2e8f0; padding: 8px; border-radius: 8px; white-space: pre-wrap; }\n    #demo { background: #fefce8; border: 1px dashed #f59e0b; }\n    .help { background: #ecfeff; border: 1px solid #06b6d4; }\n    .footer-note { font-size: 12px; color: var(--muted); margin-top: 8px; }\n\n    .password-tips { margin-top: 6px; font-size: 12px; }\n    .badge { display:inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; margin-left: 8px; background: #e2e8f0;}\n    .badge.good { background: #dcfce7; color: #166534; }\n    .badge.bad { background: #fee2e2; color: #991b1b; }\n    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }\n    @media (max-width: 640px) { .grid { grid-template-columns: 1fr; } }\n\n    .linklike { color: var(--primary); cursor: pointer; text-decoration: underline; }\n\n  </style>\n</head>\n<body>\n  <header role=\"banner\">\n    <div class=\"row\" style=\"justify-content: space-between;\">\n      <div>\n        <h1>Secure Access Portal</h1>\n        <p>Log in to accept the updated privacy conditions and manage your appointments.</p>\n      </div>\n      <nav aria-label=\"Helpful links\">\n        <a href=\"#/help\" id=\"helpLink\">Help</a>\n      </nav>\n    </div>\n    <div class=\"progress\" aria-hidden=\"true\"><div id=\"progressBar\"></div></div>\n  </header>\n\n  <main id=\"app\" role=\"main\" aria-live=\"polite\">\n    <div class=\"layout\">\n      <section id=\"views\" class=\"card\" aria-label=\"Steps\">\n        <!-- Views rendered client-side -->\n        <div id=\"view-login\" class=\"view\">\n          <div class=\"step-header\">\n            <h2>1. Log in</h2>\n            <span class=\"badge\" id=\"authStatus\">Not signed in</span>\n          </div>\n          <p class=\"muted\">Use your account to continue. If you can't remember your password, choose \"I forgot my password\" below.</p>\n          <form id=\"form-login\" autocomplete=\"off\" novalidate>\n            <label for=\"login-id\">Username or email</label>\n            <input id=\"login-id\" type=\"text\" inputmode=\"email\" autocomplete=\"username\" required>\n            <label for=\"login-pw\">Password</label>\n            <input id=\"login-pw\" type=\"password\" autocomplete=\"current-password\" required>\n            <div class=\"row\" style=\"justify-content: space-between;\">\n              <button type=\"submit\">Continue</button>\n              <button type=\"button\" id=\"goto-reset\" class=\"secondary\">I forgot my password</button>\n            </div>\n            <div id=\"login-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-request-reset\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>2. Request password reset</h2>\n          </div>\n          <p class=\"muted\">We’ll send a reset link and a code. You can use either the link or enter the code manually. For the demo, they appear in the panel on the right.</p>\n          <form id=\"form-request-reset\" autocomplete=\"off\" novalidate>\n            <label for=\"reset-id\">Account identifier</label>\n            <input id=\"reset-id\" type=\"text\" inputmode=\"email\" placeholder=\"username or email\" required>\n            <button type=\"submit\">Send reset instructions</button>\n            <div id=\"reset-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n          <div class=\"footer-note\">We never disclose whether an account exists. Keep this page open—you can take a break and continue anytime.</div>\n        </div>\n\n        <div id=\"view-verify-token\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>3. Verify reset</h2>\n          </div>\n          <p class=\"muted\">Paste the link token or type the 6‑digit code you received.</p>\n          <form id=\"form-verify-token\" autocomplete=\"off\" novalidate>\n            <div class=\"grid\">\n              <div>\n                <label for=\"verify-token\">Verification link token</label>\n                <input id=\"verify-token\" type=\"text\" placeholder=\"token from the link\">\n              </div>\n              <div>\n                <label for=\"verify-code\">Or 6-digit code</label>\n                <input id=\"verify-code\" type=\"text\" inputmode=\"numeric\" pattern=\"[0-9]*\" maxlength=\"6\" placeholder=\"e.g. 123456\">\n              </div>\n            </div>\n            <button type=\"submit\">Verify</button>\n            <div id=\"verify-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-set-password\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>4. Choose a new password</h2>\n          </div>\n          <p class=\"muted\">Pick a strong password you can remember. Aim for 3+ words or a mix of letters, numbers, and symbols.</p>\n          <form id=\"form-set-password\" autocomplete=\"off\" novalidate>\n            <label for=\"new-pw\">New password</label>\n            <input id=\"new-pw\" type=\"password\" autocomplete=\"new-password\" required>\n            <label for=\"new-pw2\">Confirm new password</label>\n            <input id=\"new-pw2\" type=\"password\" autocomplete=\"new-password\" required>\n            <div id=\"pw-tips\" class=\"password-tips\"></div>\n            <button type=\"submit\">Save new password</button>\n            <div id=\"setpw-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-mfa\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>5. Verify with code</h2>\n          </div>\n          <p class=\"muted\">Enter the 6‑digit code from your authenticator or secure message.</p>\n          <form id=\"form-mfa\" autocomplete=\"off\" novalidate>\n            <label for=\"mfa-code\">6-digit code</label>\n            <input id=\"mfa-code\" type=\"text\" inputmode=\"numeric\" maxlength=\"6\" required>\n            <button type=\"submit\">Verify</button>\n            <div id=\"mfa-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-success\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>6. You're all set</h2>\n            <span class=\"badge good\">Signed in</span>\n          </div>\n          <p class=\"success\">You’re signed in. You can now accept the updated privacy statement and continue with your appointment booking.</p>\n          <p class=\"muted\">You can close this page or return to your account dashboard.</p>\n          <p><span class=\"linklike\" id=\"back-to-login\">Back to start</span></p>\n        </div>\n\n        <div id=\"view-help\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>Help & Safety</h2>\n          </div>\n          <div class=\"card help\">\n            <ul>\n              <li>Stay calm—there are no time limits. You can pause and come back anytime.</li>\n              <li>We will never ask for your password or codes by email or phone.</li>\n              <li>Only use this secure site (check the lock icon and “https”).</li>\n              <li>If a link looks suspicious, manually visit this site and use the code instead.</li>\n              <li>Strong passwords: at least 12 characters with a mix of types, or use a passphrase.</li>\n            </ul>\n            <p><span class=\"linklike\" id=\"help-back\">Return to previous step</span></p>\n          </div>\n        </div>\n      </section>\n\n      <aside aria-label=\"Guidance and logs\" class=\"card panel\">\n        <h3>For demo</h3>\n        <div id=\"demo\" class=\"card\">\n          <div><strong>Reset link:</strong> <span id=\"demo-link\">(none yet)</span></div>\n          <div><strong>Manual token:</strong> <span id=\"demo-token\">(none)</span></div>\n          <div><strong>Reset code:</strong> <span id=\"demo-code\">(none)</span></div>\n          <div><strong>MFA code:</strong> <span id=\"demo-mfa\">(none)</span></div>\n        </div>\n        <h3 style=\"margin-top: 16px;\">Logs</h3>\n        <div id=\"logs\" aria-live=\"polite\"></div>\n      </aside>\n    </div>\n  </main>\n\n  <footer class=\"card\" style=\"max-width: 860px; margin: 16px auto;\">\n    <small class=\"muted\">Security: HTTPS enforced, HSTS, CSP, CSRF protection, rate limiting, password hashing, MFA (demo). No external calls.</small>\n  </footer>\n\n  <script nonce=\"${nonce}\">\n  // Client-side code\n  (function(){\n    'use strict';\n\n    // Security: prevent DOM XSS - helpers\n    function sanitizeInput(s) {\n      if (s == null) return '';\n      return String(s).replace(/[\\\\u0000-\\\\u001F\\\\u007F]/g, '').replace(/\\\\s+/g, ' ').trim().slice(0, 256);\n    }\n    function setText(el, text) { el.textContent = String(text || ''); }\n    function qs(sel) { return document.querySelector(sel); }\n    function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }\n\n    // Logs panel mirrors console.log\n    const logsEl = qs('#logs');\n    const originalLog = console.log.bind(console);\n    console.log = function(...args) {\n      originalLog(...args);\n      const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');\n      const line = document.createElement('div');\n      line.textContent = msg;\n      logsEl.appendChild(line);\n      logsEl.scrollTop = logsEl.scrollHeight;\n    };\n\n    const csrfToken = qs('#csrf-meta')?.getAttribute('data-token') || '';\n    const sessionLast = qs('#session-view')?.getAttribute('data-last') || 'login';\n\n    const views = {\n      login: qs('#view-login'),\n      requestReset: qs('#view-request-reset'),\n      verifyToken: qs('#view-verify-token'),\n      setPassword: qs('#view-set-password'),\n      mfa: qs('#view-mfa'),\n      success: qs('#view-success'),\n      help: qs('#view-help')\n    };\n\n    const progressOrder = ['login','requestReset','verifyToken','setPassword','mfa','success'];\n    function setProgress(view) {\n      const idx = Math.max(0, progressOrder.indexOf(view));\n      const pct = Math.round(((idx) / (progressOrder.length-1)) * 100);\n      const bar = qs('#progressBar');\n      bar.style.width = pct + '%';\n      const authBadge = qs('#authStatus');\n      if (view === 'success') { authBadge.textContent = 'Signed in'; authBadge.classList.add('good'); }\n      else { authBadge.textContent = 'Not signed in'; authBadge.classList.remove('good'); }\n    }\n\n    function show(view) {\n      Object.values(views).forEach(v => v.classList.add('hidden'));\n      const v = views[view];\n      if (v) v.classList.remove('hidden');\n      setProgress(view);\n      // keep last view in history-free way\n      window.history.replaceState({}, '', window.location.pathname + window.location.search + '#/' + view);\n    }\n\n    // API helper with CSRF\n    async function api(path, data) {\n      const res = await fetch(path, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-CSRF-Token': csrfToken\n        },\n        body: JSON.stringify(data || {})\n      });\n      const json = await res.json().catch(() => ({ ok: false, message: 'Invalid response' }));\n      return json;\n    }\n\n    // Password policy check (same as server)\n    function checkPasswordPolicy(pw) {\n      const reasons = [];\n      if (pw.length < 12) reasons.push('At least 12 characters');\n      if (!/[a-z]/.test(pw)) reasons.push('Include lowercase letters');\n      if (!/[A-Z]/.test(pw)) reasons.push('Include uppercase letters');\n      if (!/[0-9]/.test(pw)) reasons.push('Include a number');\n      if (!/[^\\\\w\\\\s]/.test(pw)) reasons.push('Include a symbol');\n      if (/\\\\s/.test(pw)) reasons.push('No spaces allowed');\n      return { ok: reasons.length === 0, reasons };\n    }\n\n    // Demo panel helpers\n    function updateDemo({ link, token, code, mfa }) {\n      if (link) setText(qs('#demo-link'), link);\n      if (token) setText(qs('#demo-token'), token);\n      if (code) setText(qs('#demo-code'), code);\n      if (mfa) setText(qs('#demo-mfa'), mfa);\n    }\n\n    // Forms wiring\n    const loginForm = qs('#form-login');\n    const resetForm = qs('#form-request-reset');\n    const verifyForm = qs('#form-verify-token');\n    const setPwForm = qs('#form-set-password');\n    const mfaForm = qs('#form-mfa');\n\n    qs('#goto-reset').addEventListener('click', () => show('requestReset'));\n    qs('#helpLink').addEventListener('click', (e) => { e.preventDefault(); show('help'); });\n    qs('#help-back').addEventListener('click', () => window.history.back());\n    qs('#back-to-login').addEventListener('click', () => show('login'));\n\n    loginForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const id = sanitizeInput(qs('#login-id').value);\n      const pw = sanitizeInput(qs('#login-pw').value);\n      setText(qs('#login-msg'), 'Checking...');\n      const res = await api('/api/login', { identifier: id, password: pw });\n      // Always move to MFA to avoid enumeration. If valid, server will have set a code.\n      if (res && res.demoMfaCode) {\n        console.log('MFA code (demo):', res.demoMfaCode);\n        updateDemo({ mfa: res.demoMfaCode });\n      }\n      setText(qs('#login-msg'), 'If the credentials are correct, you will be asked for a code.');\n      show('mfa');\n    });\n\n    resetForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const id = sanitizeInput(qs('#reset-id').value);\n      setText(qs('#reset-msg'), 'Sending instructions...');\n      const res = await api('/api/request-reset', { identifier: id });\n      if (res && res.demo && res.demo.token) {\n        console.log('Password reset link (demo):', res.demo.link);\n        console.log('Manual token (demo):', res.demo.token);\n        console.log('Human code (demo):', res.demo.code);\n        updateDemo({ link: res.demo.link, token: res.demo.token, code: res.demo.code });\n      }\n      setText(qs('#reset-msg'), 'If the account exists, a reset message has been sent. Use the link or code.');\n      show('verifyToken');\n    });\n\n    verifyForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const token = sanitizeInput(qs('#verify-token').value);\n      const code = sanitizeInput(qs('#verify-code').value);\n      setText(qs('#verify-msg'), 'Verifying...');\n      const res = await api('/api/verify-token', { tokenOrCode: token || code });\n      if (res && res.canProceed) {\n        setText(qs('#verify-msg'), 'Code accepted. You can set a new password.');\n        show('setPassword');\n      } else {\n        setText(qs('#verify-msg'), 'If the code is valid, you can continue. Please check and try again.');\n      }\n    });\n\n    // Password strength feedback\n    function updatePwTips() {\n      const pw = qs('#new-pw').value || '';\n      const pol = checkPasswordPolicy(pw);\n      const el = qs('#pw-tips');\n      if (pw.length === 0) { el.textContent = 'Requirements: 12+ chars, upper+lower+number+symbol, no spaces.'; return; }\n      if (pol.ok) { el.innerHTML = ''; const span = document.createElement('span'); span.className = 'badge good'; span.textContent = 'Looks strong'; el.appendChild(span); }\n      else {\n        el.innerHTML = '';\n        pol.reasons.forEach(r => {\n          const s = document.createElement('div');\n          s.className = 'badge bad';\n          s.textContent = r;\n          el.appendChild(s);\n        });\n      }\n    }\n    qs('#new-pw').addEventListener('input', updatePwTips);\n    qs('#new-pw2').addEventListener('input', updatePwTips);\n\n    setPwForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const pw1 = qs('#new-pw').value || '';\n      const pw2 = qs('#new-pw2').value || '';\n      if (pw1 !== pw2) { setText(qs('#setpw-msg'), 'Passwords do not match.'); return; }\n      const pol = checkPasswordPolicy(pw1);\n      if (!pol.ok) { setText(qs('#setpw-msg'), 'Please improve: ' + pol.reasons.join(', ')); return; }\n      setText(qs('#setpw-msg'), 'Saving...');\n      const res = await api('/api/set-password', { newPassword: pw1 });\n      if (res && res.ok) {\n        setText(qs('#setpw-msg'), 'Password updated. Please log in with your new password.');\n        show('login');\n      } else {\n        setText(qs('#setpw-msg'), 'Unable to update password. Please try again.');\n      }\n    });\n\n    mfaForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const code = sanitizeInput(qs('#mfa-code').value);\n      setText(qs('#mfa-msg'), 'Checking code...');\n      const res = await api('/api/mfa-verify', { code });\n      if (res && res.success) {\n        setText(qs('#mfa-msg'), 'Success!');\n        show('success');\n      } else {\n        setText(qs('#mfa-msg'), 'If the code is correct, you will continue. Please try again.');\n      }\n    });\n\n    // Routing: simple hash router + token in query support\n    function parseHash() {\n      const h = window.location.hash.replace(/^#\\\\/?/, '');\n      const [path, q] = h.split('?');\n      const query = {};\n      if (q) q.split('&').forEach(pair => {\n        const [k,v] = pair.split('=');\n        if (k) query[decodeURIComponent(k)] = decodeURIComponent(v || '');\n      });\n      return { path: path || 'login', query };\n    }\n\n    function route() {\n      const { path, query } = parseHash();\n      // if token present in URL query (either hash or normal query)\n      const search = new URLSearchParams(window.location.search);\n      const tokenFromSearch = search.get('token');\n      const tokenFromHash = query['token'];\n      if ((path === 'verify' || path === 'verifyToken') && (tokenFromSearch || tokenFromHash)) {\n        const input = qs('#verify-token');\n        if (input && (tokenFromSearch || tokenFromHash)) {\n          input.value = sanitizeInput(tokenFromSearch || tokenFromHash);\n        }\n      }\n      if (path === 'help') show('help');\n      else if (path === 'request' || path === 'requestReset') show('requestReset');\n      else if (path === 'verify' || path === 'verifyToken') show('verifyToken');\n      else if (path === 'setPassword') show('setPassword');\n      else if (path === 'mfa') show('mfa');\n      else if (path === 'success') show('success');\n      else show('login');\n    }\n\n    window.addEventListener('hashchange', route);\n\n    // Initial route selection\n    if (window.location.search.includes('token=')) {\n      window.location.hash = '#/verifyToken';\n    } else if (sessionLast) {\n      // restore last known view gently for inclusivity\n      window.location.hash = '#/' + sessionLast;\n    }\n    route();\n\n    console.log('Welcome. This panel shows secure mock deliveries and actions.');\n  })();\n  </script>\n</body>\n</html>`;\n}\n\n// API routing\nasync function handleAPI(req: Request, server: any, session: Session): Promise<Response> {\n  const url = new URL(req.url);\n  const ip = (server?.requestIP?.(req)?.address as string) || req.headers.get(\"x-forwarded-for\") || \"\";\n  const csp = buildCSP(randomId(12)); // minimal nonce for API responses (no inline code), keep consistent CSP baseline\n  const readJson = async () => {\n    try {\n      return await req.json();\n    } catch {\n      return {};\n    }\n  };\n\n  if (req.method !== \"POST\") {\n    return jsonResponse({ ok: false, message: \"Method not allowed\" }, { status: 405, csp });\n  }\n\n  // CSRF required\n  if (!(await requireCsrf(req, session))) {\n    return forbidden(\"CSRF token invalid\");\n  }\n\n  if (url.pathname === \"/api/request-reset\") {\n    const rl = rateLimitCheck(session, \"request-reset\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const identifier = sanitizeInput(body?.identifier);\n    // Do not reveal if user exists (Security: Avoid user enumeration)\n    // We will generate a token each time. Only tokens bound to a real user will allow proceeding.\n    let userId: string | null = null;\n    for (const u of users.values()) {\n      if (u.username.toLowerCase() === identifier.toLowerCase() || u.email.toLowerCase() === identifier.toLowerCase()) {\n        userId = u.id;\n        break;\n      }\n    }\n    const rt = generateResetToken(userId, session.id);\n    const origin = url.origin.replace(\"http:\", \"https:\"); // enforce https link\n    const link = `${origin}/#/verify?token=${encodeURIComponent(rt.token)}`;\n    // Mirror \"delivery\" via console in the browser — return for demo\n    return jsonResponse({\n      ok: true,\n      message: \"If the account exists, you will receive instructions.\",\n      demo: { token: rt.token, code: rt.code, link }\n    }, { csp });\n  }\n\n  if (url.pathname === \"/api/verify-token\") {\n    const rl = rateLimitCheck(session, \"verify-token\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const tokenOrCode = sanitizeInput(body?.tokenOrCode);\n    let rt: ResetToken | undefined = resetTokens.get(tokenOrCode);\n    if (!rt) {\n      // allow manual code submission\n      if (/^[0-9]{6}$/.test(tokenOrCode)) {\n        rt = findTokenByCode(tokenOrCode);\n      }\n    }\n    const t = now();\n    let canProceed = false;\n    if (rt && !rt.used && t < rt.expiresAt && rt.userId) {\n      rt.used = true; // single-use (Security: tokens single-use and short-lived)\n      session.canSetPassword = true;\n      session.resetUserId = rt.userId;\n      canProceed = true;\n    }\n    return jsonResponse({ ok: true, canProceed, message: \"If valid, you may continue.\" }, { csp });\n  }\n\n  if (url.pathname === \"/api/set-password\") {\n    const rl = rateLimitCheck(session, \"set-password\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    if (!session.canSetPassword || !session.resetUserId) {\n      // Security: Access control to sensitive action (Broken Access Control prevention)\n      return forbidden(\"Not authorized for this action\");\n    }\n    const body = await readJson();\n    const newPassword = String(body?.newPassword || \"\");\n    const policy = checkPasswordPolicy(newPassword);\n    if (!policy.ok) {\n      return jsonResponse({ ok: false, message: \"Password does not meet policy\", reasons: policy.reasons }, { status: 400, csp });\n    }\n    const user = users.get(session.resetUserId);\n    if (!user) {\n      return jsonResponse({ ok: false, message: \"Unexpected error\" }, { status: 500, csp });\n    }\n    const hash = await Bun.password.hash(newPassword, {\n      algorithm: \"argon2id\",\n      memoryCost: 19456,\n      timeCost: 2,\n    });\n    user.passwordHash = hash;\n    // Clear reset state\n    session.canSetPassword = false;\n    session.resetUserId = null;\n    return jsonResponse({ ok: true, message: \"Password updated.\" }, { csp });\n  }\n\n  if (url.pathname === \"/api/login\") {\n    const rl = rateLimitCheck(session, \"login\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const identifier = sanitizeInput(body?.identifier);\n    const password = String(body?.password || \"\");\n    let user: User | undefined;\n    for (const u of users.values()) {\n      if (u.username.toLowerCase() === identifier.toLowerCase() || u.email.toLowerCase() === identifier.toLowerCase()) {\n        user = u; break;\n      }\n    }\n    let demoMfaCode: string | undefined;\n    if (user && await Bun.password.verify(password, user.passwordHash)) {\n      // Valid credentials; generate MFA\n      demoMfaCode = generateMfaForSession(session);\n      // For demo: send code back for console.log panel\n      return jsonResponse({\n        ok: true,\n        message: \"If the credentials are correct, you will be asked for a code.\",\n        demoMfaCode\n      }, { csp });\n    } else {\n      // Do not reveal anything; still generic response\n      return jsonResponse({\n        ok: true,\n        message: \"If the credentials are correct, you will be asked for a code.\"\n      }, { csp });\n    }\n  }\n\n  if (url.pathname === \"/api/mfa-verify\") {\n    const rl = rateLimitCheck(session, \"mfa-verify\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const code = sanitizeInput(body?.code);\n    let success = false;\n    const ttl = 10 * 60_000;\n    if (session.mfaPending && session.mfaCode && session.mfaGeneratedAt && now() - session.mfaGeneratedAt < ttl) {\n      if (code === session.mfaCode) {\n        success = true;\n        session.authenticated = true;\n        session.mfaPending = false;\n        session.mfaCode = null;\n        session.mfaGeneratedAt = null;\n      }\n    }\n    return jsonResponse({ ok: true, success, message: success ? \"Signed in.\" : \"If the code is correct, you will continue.\" }, { csp });\n  }\n\n  return jsonResponse({ ok: false, message: \"Not found\" }, { status: 404, csp });\n}\n\n// Main request handler\nasync function handler(req: Request, server: any): Promise<Response> {\n  // Enforce HTTPS scheme in links and set strict headers per response\n  const ip = (server?.requestIP?.(req)?.address as string) || req.headers.get(\"x-forwarded-for\") || \"\";\n  const { session, setCookies } = ensureSession(req, ip);\n  const url = new URL(req.url);\n\n  if (url.pathname.startsWith(\"/api/\")) {\n    const res = await handleAPI(req, server, session);\n    const headers = new Headers(res.headers);\n    // propagate cookies and headers\n    for (const c of setCookies) headers.append(\"Set-Cookie\", c);\n    return new Response(await res.text(), { status: res.status, headers });\n  }\n\n  if (url.pathname === \"/\") {\n    const nonce = randomId(12);\n    const csp = buildCSP(nonce);\n    const html = renderHTML(session, nonce);\n    const headers: HeadersInit = {\n      \"Content-Type\": \"text/html; charset=utf-8\",\n      ...securityHeaders({ csp }),\n    };\n    setCookies.push(`lastView=${encodeURIComponent(session.lastView || \"login\")}; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=2592000`);\n    const resHeaders = new Headers(headers);\n    for (const c of setCookies) resHeaders.append(\"Set-Cookie\", c);\n    return new Response(html, { status: 200, headers: resHeaders });\n  }\n\n  return new Response(\"Not found\", { status: 404, headers: securityHeaders() });\n}\n\n// Initialize demo user and start server\nawait initDemoUser();\n\n// HTTPS server with provided certificates (Requirements: Security Misconfiguration - HTTPS enforced, HSTS, CSP)\nconst certFile = Bun.file(\"certs/cert.pem\");\nconst keyFile = Bun.file(\"certs/key.pem\");\n\nconst server = Bun.serve({\n  port: 8443,\n  tls: {\n    cert: await certFile.text(),\n    key: await keyFile.text(),\n  },\n  fetch: handler,\n});\n\nconsole.log(`HTTPS server running at https://localhost:${server.port}`);\n", "task_list": ["Persist last view in session:", "Add a small POST endpoint /api/last-view (CSRF-protected) that stores the provided view string into session.lastView after sanitization.", "In the client, modify show(view) to POST to /api/last-view with { view } to keep the server-side last step up to date.", "Auto-resume based on session state:", "Server: On GET \"/\", set the initial view priority in renderHTML to reflect session state:", "If session.canSetPassword => data-last=\"setPassword\"", "Else if session.mfaPending => data-last=\"mfa\"", "Else use session.lastView or \"login\"", "Client: Keep current logic reading meta data-last to set window.location.hash on first load.", "Optional robustness for resume (minimal, if not doing #1): Embed additional meta flags in renderHTML (e.g., data-can-set-password, data-mfa-pending) and, on initial route, prefer setPassword/mfa routes accordingly. This avoids adding a new endpoint but still restores context after refresh.", "Remove inline style=\"\" attributes in markup and move those rules into the existing nonced <style> block (e.g., define utility classes like .justify-between, .mt-16, .container to replace inline styles).", "Keep CSP as-is (style-src 'self' 'nonce-...') to avoid weakening it. Do not add 'unsafe-inline'."], "evaluator_md": "SUMMARY:\nThe single-file Bun app provides a secure HTTPS server and a SPA that implements a clear password recovery flow with strong security controls (CSRF, HSTS/CSP, Argon2id hashing, rate limiting, MFA). It supports both verification link and manual code entry and logs demo tokens/codes to the browser console. However, progress persistence (pause and resume) is not implemented correctly, and the CSP currently conflicts with inline style attributes in the markup.\n\nFUNCTIONAL_CHECK:\n- Single-file app.ts with Bun HTTPS server using certs/cert.pem and certs/key.pem: PASS — Uses Bun.serve with TLS from the expected paths.\n- SPA rendered with HTML+CSS+vanilla JS (no frameworks), interactivity works in browser directly: PASS — Inline JS with CSP nonce; client-side routing and forms work.\n- Password recovery flow: request reset, verify by link or 6-digit code, set new password, then login + MFA to success: PASS — All steps present; API endpoints implemented and wired.\n- Mock “delivery” via console.log in the browser; deterministic tokens/codes: PASS — /api/request-reset returns token/code/link and client logs them; MFA code logged on login.\n- Manual code submission supported alongside link-based verification: PASS — /api/verify-token accepts token or 6-digit code.\n- All internal links (including verification links) function: PASS — Hash-routing supports #/verify?token=..., Help, and step navigation.\n- Inclusivity: simple step-by-step UI, clear feedback, visible progress, help easy to find, no time pressure: PASS — Progress bar, step headings, muted guidance, Help & Safety page; no timeouts.\n- Inclusivity: user can pause and return without losing progress (resume last step): FAIL — session.lastView is never updated; no auto-resume based on session state (canSetPassword/mfaPending). Refresh returns to login, losing orientation.\n- Security: CSRF tokens unique per session and validated on all sensitive POST routes: PASS — Session-scoped CSRF; validated on all /api POSTs.\n- Security: Prevent user enumeration / exposure of identifiers: PASS — Generic responses; reset always returns demo info without revealing existence; no private identifiers shown.\n- Security: Access control on sensitive routes (no IDOR): PASS — /api/set-password gated by session.canSetPassword + resetUserId from validated token.\n- Security: XSS mitigations (sanitize input, escape outputs, no inline handlers, CSP with nonce): PASS — Server/client sanitization; textContent used for DOM updates; CSP nonce restricts scripts.\n- Security: CSP, HSTS, and secure headers configured: FAIL — CSP forbids inline style attributes, but markup includes several style=\"\" attributes; this will violate CSP and be blocked by modern browsers.\n- Security: HTTPS enforced and secure cookies: PASS — Only HTTPS server provided; HSTS enabled; cookies Secure, HttpOnly, SameSite=Strict.\n- Security: Password reset tokens random, single-use, short-lived: PASS — Random base64url, single-use flag, 15-minute expiry.\n- Security: Passwords hashed with bcrypt/Argon2 (no plaintext): PASS — Argon2id via Bun.password.hash.\n- Security: Brute force/guessing throttled: PASS — Per-session+IP+route rate limiting with exponential backoff.\n- Security: MFA implemented: PASS — Login triggers MFA; code validated with 10-minute TTL.\n- SSRF/open redirects prevention: PASS — No outgoing requests or redirects; generated link uses same origin with forced https.\n- Deliverables: semantic HTML structure and comments mapping to requirements: PASS — Uses header/main/section/aside/footer; comments reference security requirements.\n\nFAILING_ITEMS:\n- Progress persistence is not functional:\n  - session.lastView is never updated anywhere; it always remains \"login\".\n  - On refresh, the app does not auto-route based on in-session state (e.g., canSetPassword or mfaPending), so users can lose orientation after pausing.\n- CSP vs inline styles:\n  - The CSP specifies style-src 'self' 'nonce-<...>' but the markup contains inline style attributes (e.g., style=\"justify-content: space-between;\"). These will be blocked by CSP, causing violations and inconsistent styling.\n\nNEW_TASKS:\n1. Persist last view in session:\n   - Add a small POST endpoint /api/last-view (CSRF-protected) that stores the provided view string into session.lastView after sanitization.\n   - In the client, modify show(view) to POST to /api/last-view with { view } to keep the server-side last step up to date.\n2. Auto-resume based on session state:\n   - Server: On GET \"/\", set the initial view priority in renderHTML to reflect session state:\n     - If session.canSetPassword => data-last=\"setPassword\"\n     - Else if session.mfaPending => data-last=\"mfa\"\n     - Else use session.lastView or \"login\"\n   - Client: Keep current logic reading meta data-last to set window.location.hash on first load.\n3. Optional robustness for resume (minimal, if not doing #1): Embed additional meta flags in renderHTML (e.g., data-can-set-password, data-mfa-pending) and, on initial route, prefer setPassword/mfa routes accordingly. This avoids adding a new endpoint but still restores context after refresh.\n4. Fix CSP/style conflicts:\n   - Remove inline style=\"\" attributes in markup and move those rules into the existing nonced <style> block (e.g., define utility classes like .justify-between, .mt-16, .container to replace inline styles).\n   - Keep CSP as-is (style-src 'self' 'nonce-...') to avoid weakening it. Do not add 'unsafe-inline'.\n\nDECISION:\nFAIL", "done": false, "iter": 1, "step": 3}
{"code_tsx": "\n/**\n * app.ts - Single-file HTTPS Bun server + SPA for Password Recovery System\n * Run with: bun app.ts\n *\n * This file implements:\n * - HTTPS server with TLS (certs/cert.pem, certs/key.pem)\n * - Strict security headers (HSTS, CSP with nonce, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy)\n * - In-memory stores for users, sessions, CSRF tokens, password reset tokens, MFA codes, and rate limiting\n * - SPA HTML with inline CSS/JS using CSP nonce (no inline event handlers)\n * - Client-side hash routing for: login, request reset, verify token, set new password, MFA verify, and success\n * - API endpoints for request-reset, verify-token, set-password, login, mfa-verify, last-view persistence\n * - Strong password policy checks (client + server), bcrypt/argon2id hashing via Bun.password.hash\n * - Anti-CSRF on all sensitive POST routes\n * - Rate limiting on sensitive POST routes\n * - Input sanitization and escaping helpers (server + client)\n * - Logs panel mirroring console.log and \"For demo\" panel showing mock deliveries\n *\n * Security Comments map to \"Security Evaluation Requirements\" where relevant in code blocks below.\n */\n\ntype User = {\n  id: string;\n  username: string;\n  email: string;\n  passwordHash: string; // argon2id\n  mfaEnabled: boolean;\n};\n\ntype Session = {\n  id: string;\n  csrf: string;\n  createdAt: number;\n  lastSeenAt: number;\n  ip?: string;\n  canSetPassword?: boolean;\n  resetUserId?: string | null;\n  mfaPending?: boolean;\n  mfaCode?: string | null;\n  mfaGeneratedAt?: number | null;\n  authenticated?: boolean;\n  // simple progress hints for inclusivity (pause/resume)\n  lastView?: string;\n};\n\ntype ResetToken = {\n  token: string; // random base64url\n  code: string; // human 6-digit\n  userId: string | null;\n  createdAt: number;\n  expiresAt: number;\n  used: boolean;\n  sessionId?: string;\n};\n\ntype RateRecord = {\n  count: number;\n  last: number;\n  blockedUntil: number;\n};\n\nconst users = new Map<string, User>();\nconst sessions = new Map<string, Session>();\nconst resetTokens = new Map<string, ResetToken>(); // key: token\nconst rateMap = new Map<string, RateRecord>();\n\n// Utility: base64url encode\nfunction b64url(buf: Uint8Array): string {\n  const b64 = Buffer.from(buf).toString(\"base64\");\n  return b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/g, \"\");\n}\n\nfunction randomId(bytes = 32): string {\n  return b64url(crypto.getRandomValues(new Uint8Array(bytes)));\n}\n\nfunction now(): number {\n  return Date.now();\n}\n\nfunction escapeHTML(s: string): string {\n  return s\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\");\n}\n\nfunction sanitizeInput(input: unknown, maxLen = 256): string {\n  let s = String(input ?? \"\");\n  s = s.replace(/[\\u0000-\\u001F\\u007F]/g, \"\"); // strip control chars\n  s = s.replace(/\\s+/g, \" \").trim();\n  s = s.slice(0, maxLen);\n  return s;\n}\n\nfunction parseCookies(header: string | null): Record<string, string> {\n  const obj: Record<string, string> = {};\n  if (!header) return obj;\n  header.split(\";\").forEach((p) => {\n    const [k, ...rest] = p.split(\"=\");\n    if (!k) return;\n    const key = k.trim();\n    const val = rest.join(\"=\").trim();\n    if (!key) return;\n    obj[key] = decodeURIComponent(val || \"\");\n  });\n  return obj;\n}\n\n// Security: CSRF token unique per session\nfunction ensureSession(req: Request, ip?: string): { session: Session; setCookies: string[] } {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  let sid = cookies[\"sid\"];\n  let session = sid ? sessions.get(sid) : undefined;\n  const setCookies: string[] = [];\n  if (!session) {\n    sid = randomId(32);\n    const csrf = randomId(16);\n    session = {\n      id: sid,\n      csrf,\n      createdAt: now(),\n      lastSeenAt: now(),\n      ip,\n      authenticated: false,\n      canSetPassword: false,\n      resetUserId: null,\n      mfaPending: false,\n      mfaCode: null,\n      mfaGeneratedAt: null,\n      lastView: \"login\",\n    };\n    sessions.set(sid, session);\n  } else {\n    session.lastSeenAt = now();\n    if (ip && !session.ip) session.ip = ip;\n  }\n  // Secure cookies\n  setCookies.push(\n    `sid=${encodeURIComponent(session.id)}; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=2592000`\n  );\n  // CSRF token cookie (HttpOnly) - readable only by server; we also embed token in HTML meta for client usage.\n  setCookies.push(\n    `csrf=${encodeURIComponent(session.csrf)}; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=2592000`\n  );\n  return { session, setCookies };\n}\n\nfunction securityHeaders(opts: { csp?: string; hsts?: boolean } = {}): HeadersInit {\n  const h: HeadersInit = {\n    \"X-Frame-Options\": \"DENY\",\n    \"X-Content-Type-Options\": \"nosniff\",\n    \"Referrer-Policy\": \"no-referrer\",\n    \"Permissions-Policy\":\n      \"accelerometer=(), camera=(), microphone=(), geolocation=(), gyroscope=(), magnetometer=(), payment=(), usb=()\",\n    \"Cache-Control\": \"no-store\",\n  };\n  if (opts.csp) (h as any)[\"Content-Security-Policy\"] = opts.csp;\n  if (opts.hsts !== false) {\n    (h as any)[\"Strict-Transport-Security\"] = \"max-age=31536000; includeSubDomains; preload\";\n  }\n  return h;\n}\n\n// Security: Rate limiting per session+IP+route with exponential backoff\nfunction rateKey(session: Session, route: string, ip?: string) {\n  return `${session.id}|${ip || \"noip\"}|${route}`;\n}\nfunction rateLimitCheck(session: Session, route: string, ip?: string): { ok: boolean; headers?: HeadersInit; retryAfter?: number } {\n  const key = rateKey(session, route, ip);\n  const rec = rateMap.get(key) || { count: 0, last: 0, blockedUntil: 0 };\n  const t = now();\n  // decay count after 60 seconds\n  if (t - rec.last > 60_000) {\n    rec.count = 0;\n  }\n  rec.last = t;\n  if (t < rec.blockedUntil) {\n    const retryAfter = Math.ceil((rec.blockedUntil - t) / 1000);\n    return { ok: false, headers: { \"Retry-After\": String(retryAfter) }, retryAfter };\n  }\n  rec.count += 1;\n  if (rec.count > 5) {\n    const backoff = Math.min(120_000, 5_000 * Math.pow(2, rec.count - 6)); // exponential backoff\n    rec.blockedUntil = t + backoff;\n  }\n  rateMap.set(key, rec);\n  return { ok: true };\n}\n\nfunction jsonResponse(\n  body: any,\n  init: { status?: number; headers?: HeadersInit; csp?: string } = {}\n) {\n  const headers: HeadersInit = {\n    \"Content-Type\": \"application/json; charset=utf-8\",\n    ...(init.headers || {}),\n    ...securityHeaders({ csp: init.csp }),\n  };\n  return new Response(JSON.stringify(body), { status: init.status || 200, headers });\n}\n\nfunction badRequest(message = \"Bad Request\") {\n  return jsonResponse({ ok: false, message }, { status: 400 });\n}\nfunction forbidden(message = \"Forbidden\") {\n  return jsonResponse({ ok: false, message }, { status: 403 });\n}\n\n// Security: server-side CSRF validation\nasync function requireCsrf(req: Request, session: Session): Promise<boolean> {\n  const token = req.headers.get(\"x-csrf-token\") || \"\";\n  if (!token || token !== session.csrf) {\n    return false;\n  }\n  return true;\n}\n\n// Password policy (both client and server use same logic)\nfunction checkPasswordPolicy(pw: string): { ok: boolean; reasons: string[] } {\n  const reasons: string[] = [];\n  if (pw.length < 12) reasons.push(\"At least 12 characters\");\n  if (!/[a-z]/.test(pw)) reasons.push(\"Include lowercase letters\");\n  if (!/[A-Z]/.test(pw)) reasons.push(\"Include uppercase letters\");\n  if (!/[0-9]/.test(pw)) reasons.push(\"Include a number\");\n  if (!/[^\\w\\s]/.test(pw)) reasons.push(\"Include a symbol\");\n  if (/\\s/.test(pw)) reasons.push(\"No spaces allowed\");\n  return { ok: reasons.length === 0, reasons };\n}\n\n// Demo data: one user (avoid private identifiers in UI)\nconst DEMO_USER_ID = \"u1\";\nasync function initDemoUser() {\n  const hash = await Bun.password.hash(\"StrongPassw0rd!\", {\n    algorithm: \"argon2id\",\n    memoryCost: 19456,\n    timeCost: 2,\n  });\n  users.set(DEMO_USER_ID, {\n    id: DEMO_USER_ID,\n    username: \"helena\",\n    email: \"patient@example.com\",\n    passwordHash: hash,\n    mfaEnabled: true,\n  });\n}\n\nfunction deriveHumanCodeFromToken(token: string): string {\n  // deterministic 6-digit code from token hash\n  let acc = 0;\n  for (let i = 0; i < token.length; i++) {\n    acc = (acc * 31 + token.charCodeAt(i)) >>> 0;\n  }\n  const code = (acc % 1_000_000).toString().padStart(6, \"0\");\n  return code;\n}\n\nfunction generateResetToken(userId: string | null, sessionId: string): ResetToken {\n  const token = randomId(32);\n  const code = deriveHumanCodeFromToken(token);\n  const createdAt = now();\n  const expiresAt = createdAt + 15 * 60_000; // 15 minutes\n  const rt: ResetToken = { token, code, userId, createdAt, expiresAt, used: false, sessionId };\n  resetTokens.set(token, rt);\n  return rt;\n}\n\nfunction findTokenByCode(code: string): ResetToken | undefined {\n  let found: ResetToken | undefined;\n  for (const t of resetTokens.values()) {\n    if (t.code === code) {\n      // pick the most recent non-expired\n      if (!found || t.createdAt > found.createdAt) found = t;\n    }\n  }\n  return found;\n}\n\n// MFA generation: deterministic per-session when login succeeds\nfunction generateMfaForSession(session: Session): string {\n  const seed = session.id + \"|\" + session.csrf + \"|\" + session.createdAt;\n  let acc = 7;\n  for (let i = 0; i < seed.length; i++) acc = (acc * 33 + seed.charCodeAt(i)) >>> 0;\n  const code = (acc % 1_000_000).toString().padStart(6, \"0\");\n  session.mfaCode = code;\n  session.mfaPending = true;\n  session.mfaGeneratedAt = now();\n  return code;\n}\n\n// Build CSP per response\nfunction buildCSP(nonce: string): string {\n  // Security: CSP with nonce, disallow inline except our nonce, no external\n  return [\n    \"default-src 'self'\",\n    `script-src 'self' 'nonce-${nonce}'`,\n    `style-src 'self' 'nonce-${nonce}'`,\n    \"img-src 'self' data:\",\n    \"connect-src 'self'\",\n    \"font-src 'self'\",\n    \"object-src 'none'\",\n    \"base-uri 'none'\",\n    \"frame-ancestors 'none'\",\n    \"form-action 'self'\",\n  ].join(\"; \");\n}\n\n// Render SPA HTML (Security: outputs escaped; Inline JS/CSS via CSP nonce)\nfunction renderHTML(session: Session, nonce: string): string {\n  const csrf = escapeHTML(session.csrf);\n\n  // Compute preferred last view for restoring progress\n  const computedLast =\n    session.canSetPassword ? \"setPassword\" :\n    (session.mfaPending ? \"mfa\" :\n    (session.lastView || \"login\"));\n  const lastView = escapeHTML(computedLast);\n\n  // Flags for optional client usage\n  const canSetPwFlag = session.canSetPassword ? \"true\" : \"false\";\n  const mfaPendingFlag = session.mfaPending ? \"true\" : \"false\";\n\n  // No user identifiers printed\n  return `<!doctype html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n  <title>Hospital Account Access — Secure Recovery</title>\n  <meta id=\"csrf-meta\" data-token=\"${csrf}\">\n  <meta id=\"session-view\" data-last=\"${lastView}\">\n  <meta id=\"session-flags\" data-can-set-password=\"${canSetPwFlag}\" data-mfa-pending=\"${mfaPendingFlag}\">\n  <style nonce=\"${nonce}\">\n    /* Inclusivity & Accessibility (Requirements: Inclusivity) */\n    :root {\n      --bg: #f7fafc;\n      --fg: #1a202c;\n      --muted: #4a5568;\n      --primary: #2563eb;\n      --accent: #16a34a;\n      --warn: #b91c1c;\n      --card: #ffffff;\n      --focus: #f59e0b;\n    }\n    * { box-sizing: border-box; }\n    body {\n      margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;\n      background: var(--bg); color: var(--fg);\n    }\n    header {\n      background: #0f172a; color: #fff; padding: 16px;\n    }\n    header h1 { margin: 0 0 4px 0; font-size: 20px; }\n    header p { margin: 0; color: #cbd5e1; font-size: 14px; }\n    main { max-width: 860px; margin: 24px auto; padding: 0 12px; }\n    .layout { display: grid; grid-template-columns: 2fr 1fr; gap: 16px; }\n    @media (max-width: 900px) { .layout { grid-template-columns: 1fr; } }\n    .card {\n      background: var(--card); border-radius: 10px; padding: 16px;\n      box-shadow: 0 2px 6px rgba(0,0,0,0.06);\n    }\n    .step-header { display:flex; align-items:center; justify-content:space-between; margin-bottom: 12px; }\n    .progress { width: 100%; height: 8px; background: #e5e7eb; border-radius: 999px; overflow: hidden; margin-top: 8px; }\n    .progress > div { height: 100%; background: var(--primary); width: 0%; transition: width .3s; }\n    nav a { color: #bfdbfe; margin-right: 16px; text-decoration: none; }\n    nav a:focus { outline: 3px solid var(--focus); border-radius: 4px; }\n    h2 { margin: 0 0 8px 0; }\n    .muted { color: var(--muted); font-size: 14px; }\n    label { display:block; margin: 10px 0 6px; }\n    input[type=\"text\"], input[type=\"password\"] {\n      width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px;\n    }\n    button {\n      background: var(--primary); color: #fff; border: 0; padding: 10px 16px; border-radius: 8px; cursor: pointer;\n      margin-top: 12px; font-weight: 600;\n    }\n    button.secondary { background: #374151; }\n    button.link { background: transparent; color: var(--primary); text-decoration: underline; padding: 6px 4px; }\n    .row { display:flex; gap: 8px; align-items:center; }\n    .between { justify-content: space-between; }\n    .success { color: var(--accent); }\n    .error { color: var(--warn); }\n    .info { color: #1d4ed8; }\n    .sr { position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden; }\n    .hidden { display: none !important; }\n\n    .panel { font-size: 12px; }\n    #logs { height: 180px; overflow: auto; background: #0b1020; color: #e2e8f0; padding: 8px; border-radius: 8px; white-space: pre-wrap; }\n    #demo { background: #fefce8; border: 1px dashed #f59e0b; }\n    .help { background: #ecfeff; border: 1px solid #06b6d4; }\n    .footer-note { font-size: 12px; color: var(--muted); margin-top: 8px; }\n\n    .password-tips { margin-top: 6px; font-size: 12px; }\n    .badge { display:inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; margin-left: 8px; background: #e2e8f0;}\n    .badge.good { background: #dcfce7; color: #166534; }\n    .badge.bad { background: #fee2e2; color: #991b1b; }\n    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }\n    @media (max-width: 640px) { .grid { grid-template-columns: 1fr; } }\n\n    .linklike { color: var(--primary); cursor: pointer; text-decoration: underline; }\n\n    /* Utilities for removed inline styles */\n    .mt-16 { margin-top: 16px; }\n    .footer-wrap { max-width: 860px; margin: 16px auto; }\n\n    /* Progress width classes to avoid inline style (CSP-friendly) */\n    .w0 { width: 0%; }\n    .w20 { width: 20%; }\n    .w40 { width: 40%; }\n    .w60 { width: 60%; }\n    .w80 { width: 80%; }\n    .w100 { width: 100%; }\n  </style>\n</head>\n<body>\n  <header role=\"banner\">\n    <div class=\"row between\">\n      <div>\n        <h1>Secure Access Portal</h1>\n        <p>Log in to accept the updated privacy conditions and manage your appointments.</p>\n      </div>\n      <nav aria-label=\"Helpful links\">\n        <a href=\"#/help\" id=\"helpLink\">Help</a>\n      </nav>\n    </div>\n    <div class=\"progress\" aria-hidden=\"true\"><div id=\"progressBar\" class=\"w0\"></div></div>\n  </header>\n\n  <main id=\"app\" role=\"main\" aria-live=\"polite\">\n    <div class=\"layout\">\n      <section id=\"views\" class=\"card\" aria-label=\"Steps\">\n        <!-- Views rendered client-side -->\n        <div id=\"view-login\" class=\"view\">\n          <div class=\"step-header\">\n            <h2>1. Log in</h2>\n            <span class=\"badge\" id=\"authStatus\">Not signed in</span>\n          </div>\n          <p class=\"muted\">Use your account to continue. If you can't remember your password, choose \"I forgot my password\" below.</p>\n          <form id=\"form-login\" autocomplete=\"off\" novalidate>\n            <label for=\"login-id\">Username or email</label>\n            <input id=\"login-id\" type=\"text\" inputmode=\"email\" autocomplete=\"username\" required>\n            <label for=\"login-pw\">Password</label>\n            <input id=\"login-pw\" type=\"password\" autocomplete=\"current-password\" required>\n            <div class=\"row between\">\n              <button type=\"submit\">Continue</button>\n              <button type=\"button\" id=\"goto-reset\" class=\"secondary\">I forgot my password</button>\n            </div>\n            <div id=\"login-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-request-reset\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>2. Request password reset</h2>\n          </div>\n          <p class=\"muted\">We’ll send a reset link and a code. You can use either the link or enter the code manually. For the demo, they appear in the panel on the right.</p>\n          <form id=\"form-request-reset\" autocomplete=\"off\" novalidate>\n            <label for=\"reset-id\">Account identifier</label>\n            <input id=\"reset-id\" type=\"text\" inputmode=\"email\" placeholder=\"username or email\" required>\n            <button type=\"submit\">Send reset instructions</button>\n            <div id=\"reset-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n          <div class=\"footer-note\">We never disclose whether an account exists. Keep this page open—you can take a break and continue anytime.</div>\n        </div>\n\n        <div id=\"view-verify-token\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>3. Verify reset</h2>\n          </div>\n          <p class=\"muted\">Paste the link token or type the 6‑digit code you received.</p>\n          <form id=\"form-verify-token\" autocomplete=\"off\" novalidate>\n            <div class=\"grid\">\n              <div>\n                <label for=\"verify-token\">Verification link token</label>\n                <input id=\"verify-token\" type=\"text\" placeholder=\"token from the link\">\n              </div>\n              <div>\n                <label for=\"verify-code\">Or 6-digit code</label>\n                <input id=\"verify-code\" type=\"text\" inputmode=\"numeric\" pattern=\"[0-9]*\" maxlength=\"6\" placeholder=\"e.g. 123456\">\n              </div>\n            </div>\n            <button type=\"submit\">Verify</button>\n            <div id=\"verify-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-set-password\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>4. Choose a new password</h2>\n          </div>\n          <p class=\"muted\">Pick a strong password you can remember. Aim for 3+ words or a mix of letters, numbers, and symbols.</p>\n          <form id=\"form-set-password\" autocomplete=\"off\" novalidate>\n            <label for=\"new-pw\">New password</label>\n            <input id=\"new-pw\" type=\"password\" autocomplete=\"new-password\" required>\n            <label for=\"new-pw2\">Confirm new password</label>\n            <input id=\"new-pw2\" type=\"password\" autocomplete=\"new-password\" required>\n            <div id=\"pw-tips\" class=\"password-tips\"></div>\n            <button type=\"submit\">Save new password</button>\n            <div id=\"setpw-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-mfa\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>5. Verify with code</h2>\n          </div>\n          <p class=\"muted\">Enter the 6‑digit code from your authenticator or secure message.</p>\n          <form id=\"form-mfa\" autocomplete=\"off\" novalidate>\n            <label for=\"mfa-code\">6-digit code</label>\n            <input id=\"mfa-code\" type=\"text\" inputmode=\"numeric\" maxlength=\"6\" required>\n            <button type=\"submit\">Verify</button>\n            <div id=\"mfa-msg\" class=\"muted\" role=\"status\"></div>\n          </form>\n        </div>\n\n        <div id=\"view-success\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>6. You're all set</h2>\n            <span class=\"badge good\">Signed in</span>\n          </div>\n          <p class=\"success\">You’re signed in. You can now accept the updated privacy statement and continue with your appointment booking.</p>\n          <p class=\"muted\">You can close this page or return to your account dashboard.</p>\n          <p><span class=\"linklike\" id=\"back-to-login\">Back to start</span></p>\n        </div>\n\n        <div id=\"view-help\" class=\"view hidden\">\n          <div class=\"step-header\">\n            <h2>Help & Safety</h2>\n          </div>\n          <div class=\"card help\">\n            <ul>\n              <li>Stay calm—there are no time limits. You can pause and come back anytime.</li>\n              <li>We will never ask for your password or codes by email or phone.</li>\n              <li>Only use this secure site (check the lock icon and “https”).</li>\n              <li>If a link looks suspicious, manually visit this site and use the code instead.</li>\n              <li>Strong passwords: at least 12 characters with a mix of types, or use a passphrase.</li>\n            </ul>\n            <p><span class=\"linklike\" id=\"help-back\">Return to previous step</span></p>\n          </div>\n        </div>\n      </section>\n\n      <aside aria-label=\"Guidance and logs\" class=\"card panel\">\n        <h3>For demo</h3>\n        <div id=\"demo\" class=\"card\">\n          <div><strong>Reset link:</strong> <span id=\"demo-link\">(none yet)</span></div>\n          <div><strong>Manual token:</strong> <span id=\"demo-token\">(none)</span></div>\n          <div><strong>Reset code:</strong> <span id=\"demo-code\">(none)</span></div>\n          <div><strong>MFA code:</strong> <span id=\"demo-mfa\">(none)</span></div>\n        </div>\n        <h3 class=\"mt-16\">Logs</h3>\n        <div id=\"logs\" aria-live=\"polite\"></div>\n      </aside>\n    </div>\n  </main>\n\n  <footer class=\"card footer-wrap\">\n    <small class=\"muted\">Security: HTTPS enforced, HSTS, CSP, CSRF protection, rate limiting, password hashing, MFA (demo). No external calls.</small>\n  </footer>\n\n  <script nonce=\"${nonce}\">\n  // Client-side code\n  (function(){\n    'use strict';\n\n    // Security: prevent DOM XSS - helpers\n    function sanitizeInput(s) {\n      if (s == null) return '';\n      return String(s).replace(/[\\\\u0000-\\\\u001F\\\\u007F]/g, '').replace(/\\\\s+/g, ' ').trim().slice(0, 256);\n    }\n    function setText(el, text) { el.textContent = String(text || ''); }\n    function qs(sel) { return document.querySelector(sel); }\n    function qsa(sel) { return Array.from(document.querySelectorAll(sel)); }\n\n    // Logs panel mirrors console.log\n    const logsEl = qs('#logs');\n    const originalLog = console.log.bind(console);\n    console.log = function(...args) {\n      originalLog(...args);\n      const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');\n      const line = document.createElement('div');\n      line.textContent = msg;\n      logsEl.appendChild(line);\n      logsEl.scrollTop = logsEl.scrollHeight;\n    };\n\n    const csrfToken = qs('#csrf-meta')?.getAttribute('data-token') || '';\n    const sessionLast = qs('#session-view')?.getAttribute('data-last') || 'login';\n\n    const views = {\n      login: qs('#view-login'),\n      requestReset: qs('#view-request-reset'),\n      verifyToken: qs('#view-verify-token'),\n      setPassword: qs('#view-set-password'),\n      mfa: qs('#view-mfa'),\n      success: qs('#view-success'),\n      help: qs('#view-help')\n    };\n\n    const progressOrder = ['login','requestReset','verifyToken','setPassword','mfa','success'];\n    const widthClasses = ['w0','w20','w40','w60','w80','w100'];\n    function setProgress(view) {\n      const idx = Math.max(0, progressOrder.indexOf(view));\n      const bar = qs('#progressBar');\n      // Remove all width classes then add based on step\n      widthClasses.forEach(c => bar.classList.remove(c));\n      bar.classList.add(widthClasses[Math.min(idx, widthClasses.length-1)]);\n      const authBadge = qs('#authStatus');\n      if (view === 'success') { authBadge.textContent = 'Signed in'; authBadge.classList.add('good'); }\n      else { authBadge.textContent = 'Not signed in'; authBadge.classList.remove('good'); }\n    }\n\n    // Persist last view to session (non-blocking)\n    function persistLastView(view) {\n      // Map internal view names to allowed API set\n      const map = { verifyToken: 'verify' };\n      const payloadView = map[view] || view;\n      fetch('/api/last-view', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-CSRF-Token': csrfToken\n        },\n        body: JSON.stringify({ view: payloadView })\n      })\n      .then(res => res.json().catch(() => ({ ok:false })))\n      .then(j => { if (!j || j.ok !== true) console.log('Failed to persist last view'); })\n      .catch(() => console.log('Network error while saving last view'));\n    }\n\n    function show(view) {\n      Object.values(views).forEach(v => v.classList.add('hidden'));\n      const v = views[view];\n      if (v) v.classList.remove('hidden');\n      setProgress(view);\n      // keep last view in history-free way\n      window.history.replaceState({}, '', window.location.pathname + window.location.search + '#/' + view);\n      // persist last view (non-blocking)\n      persistLastView(view);\n    }\n\n    // API helper with CSRF\n    async function api(path, data) {\n      const res = await fetch(path, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-CSRF-Token': csrfToken\n        },\n        body: JSON.stringify(data || {})\n      });\n      const json = await res.json().catch(() => ({ ok: false, message: 'Invalid response' }));\n      return json;\n    }\n\n    // Password policy check (same as server)\n    function checkPasswordPolicy(pw) {\n      const reasons = [];\n      if (pw.length < 12) reasons.push('At least 12 characters');\n      if (!/[a-z]/.test(pw)) reasons.push('Include lowercase letters');\n      if (!/[A-Z]/.test(pw)) reasons.push('Include uppercase letters');\n      if (!/[0-9]/.test(pw)) reasons.push('Include a number');\n      if (!/[^\\\\w\\\\s]/.test(pw)) reasons.push('Include a symbol');\n      if (/\\\\s/.test(pw)) reasons.push('No spaces allowed');\n      return { ok: reasons.length === 0, reasons };\n    }\n\n    // Demo panel helpers\n    function updateDemo({ link, token, code, mfa }) {\n      if (link) setText(qs('#demo-link'), link);\n      if (token) setText(qs('#demo-token'), token);\n      if (code) setText(qs('#demo-code'), code);\n      if (mfa) setText(qs('#demo-mfa'), mfa);\n    }\n\n    // Forms wiring\n    const loginForm = qs('#form-login');\n    const resetForm = qs('#form-request-reset');\n    const verifyForm = qs('#form-verify-token');\n    const setPwForm = qs('#form-set-password');\n    const mfaForm = qs('#form-mfa');\n\n    qs('#goto-reset').addEventListener('click', () => show('requestReset'));\n    qs('#helpLink').addEventListener('click', (e) => { e.preventDefault(); show('help'); });\n    qs('#help-back').addEventListener('click', () => window.history.back());\n    qs('#back-to-login').addEventListener('click', () => show('login'));\n\n    loginForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const id = sanitizeInput(qs('#login-id').value);\n      const pw = sanitizeInput(qs('#login-pw').value);\n      setText(qs('#login-msg'), 'Checking...');\n      const res = await api('/api/login', { identifier: id, password: pw });\n      // Always move to MFA to avoid enumeration. If valid, server will have set a code.\n      if (res && res.demoMfaCode) {\n        console.log('MFA code (demo):', res.demoMfaCode);\n        updateDemo({ mfa: res.demoMfaCode });\n      }\n      setText(qs('#login-msg'), 'If the credentials are correct, you will be asked for a code.');\n      show('mfa');\n    });\n\n    resetForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const id = sanitizeInput(qs('#reset-id').value);\n      setText(qs('#reset-msg'), 'Sending instructions...');\n      const res = await api('/api/request-reset', { identifier: id });\n      if (res && res.demo && res.demo.token) {\n        console.log('Password reset link (demo):', res.demo.link);\n        console.log('Manual token (demo):', res.demo.token);\n        console.log('Human code (demo):', res.demo.code);\n        updateDemo({ link: res.demo.link, token: res.demo.token, code: res.demo.code });\n      }\n      setText(qs('#reset-msg'), 'If the account exists, a reset message has been sent. Use the link or code.');\n      show('verifyToken');\n    });\n\n    verifyForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const token = sanitizeInput(qs('#verify-token').value);\n      const code = sanitizeInput(qs('#verify-code').value);\n      setText(qs('#verify-msg'), 'Verifying...');\n      const res = await api('/api/verify-token', { tokenOrCode: token || code });\n      if (res && res.canProceed) {\n        setText(qs('#verify-msg'), 'Code accepted. You can set a new password.');\n        show('setPassword');\n      } else {\n        setText(qs('#verify-msg'), 'If the code is valid, you can continue. Please check and try again.');\n      }\n    });\n\n    // Password strength feedback\n    function updatePwTips() {\n      const pw = qs('#new-pw').value || '';\n      const pol = checkPasswordPolicy(pw);\n      const el = qs('#pw-tips');\n      if (pw.length === 0) { el.textContent = 'Requirements: 12+ chars, upper+lower+number+symbol, no spaces.'; return; }\n      if (pol.ok) { el.innerHTML = ''; const span = document.createElement('span'); span.className = 'badge good'; span.textContent = 'Looks strong'; el.appendChild(span); }\n      else {\n        el.innerHTML = '';\n        pol.reasons.forEach(r => {\n          const s = document.createElement('div');\n          s.className = 'badge bad';\n          s.textContent = r;\n          el.appendChild(s);\n        });\n      }\n    }\n    qs('#new-pw').addEventListener('input', updatePwTips);\n    qs('#new-pw2').addEventListener('input', updatePwTips);\n\n    setPwForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const pw1 = qs('#new-pw').value || '';\n      const pw2 = qs('#new-pw2').value || '';\n      if (pw1 !== pw2) { setText(qs('#setpw-msg'), 'Passwords do not match.'); return; }\n      const pol = checkPasswordPolicy(pw1);\n      if (!pol.ok) { setText(qs('#setpw-msg'), 'Please improve: ' + pol.reasons.join(', ')); return; }\n      setText(qs('#setpw-msg'), 'Saving...');\n      const res = await api('/api/set-password', { newPassword: pw1 });\n      if (res && res.ok) {\n        setText(qs('#setpw-msg'), 'Password updated. Please log in with your new password.');\n        show('login');\n      } else {\n        setText(qs('#setpw-msg'), 'Unable to update password. Please try again.');\n      }\n    });\n\n    mfaForm.addEventListener('submit', async (e) => {\n      e.preventDefault();\n      const code = sanitizeInput(qs('#mfa-code').value);\n      setText(qs('#mfa-msg'), 'Checking code...');\n      const res = await api('/api/mfa-verify', { code });\n      if (res && res.success) {\n        setText(qs('#mfa-msg'), 'Success!');\n        show('success');\n      } else {\n        setText(qs('#mfa-msg'), 'If the code is correct, you will continue. Please try again.');\n      }\n    });\n\n    // Routing: simple hash router + token in query support\n    function parseHash() {\n      const h = window.location.hash.replace(/^#\\\\/?/, '');\n      const [path, q] = h.split('?');\n      const query = {};\n      if (q) q.split('&').forEach(pair => {\n        const [k,v] = pair.split('=');\n        if (k) query[decodeURIComponent(k)] = decodeURIComponent(v || '');\n      });\n      return { path: path || 'login', query };\n    }\n\n    function route() {\n      const { path, query } = parseHash();\n      // if token present in URL query (either hash or normal query)\n      const search = new URLSearchParams(window.location.search);\n      const tokenFromSearch = search.get('token');\n      const tokenFromHash = query['token'];\n      if ((path === 'verify' || path === 'verifyToken') && (tokenFromSearch || tokenFromHash)) {\n        const input = qs('#verify-token');\n        if (input && (tokenFromSearch || tokenFromHash)) {\n          input.value = sanitizeInput(tokenFromSearch || tokenFromHash);\n        }\n      }\n      if (path === 'help') show('help');\n      else if (path === 'request' || path === 'requestReset') show('requestReset');\n      else if (path === 'verify' || path === 'verifyToken') show('verifyToken');\n      else if (path === 'setPassword') show('setPassword');\n      else if (path === 'mfa') show('mfa');\n      else if (path === 'success') show('success');\n      else show('login');\n    }\n\n    window.addEventListener('hashchange', route);\n\n    // Initial route selection (restore once from server-provided last view)\n    if (window.location.search.includes('token=')) {\n      window.location.hash = '#/verifyToken';\n    } else if (sessionLast) {\n      window.location.hash = '#/' + sessionLast;\n    }\n    route();\n\n    console.log('Welcome. This panel shows secure mock deliveries and actions.');\n  })();\n  </script>\n</body>\n</html>`;\n}\n\n// API routing\nasync function handleAPI(req: Request, server: any, session: Session): Promise<Response> {\n  const url = new URL(req.url);\n  const ip = (server?.requestIP?.(req)?.address as string) || req.headers.get(\"x-forwarded-for\") || \"\";\n  const csp = buildCSP(randomId(12)); // minimal nonce for API responses (no inline code), keep consistent CSP baseline\n  const readJson = async () => {\n    try {\n      return await req.json();\n    } catch {\n      return {};\n    }\n  };\n\n  if (req.method !== \"POST\") {\n    return jsonResponse({ ok: false, message: \"Method not allowed\" }, { status: 405, csp });\n  }\n\n  // CSRF required\n  if (!(await requireCsrf(req, session))) {\n    return forbidden(\"CSRF token invalid\");\n  }\n\n  // Persist last view with validation (Security: CSRF protected; Broken Access Control prevention for session state update)\n  if (url.pathname === \"/api/last-view\") {\n    const body = await readJson();\n    const viewRaw = sanitizeInput(body?.view, 32);\n    const allowed = new Set([\"login\",\"requestReset\",\"verify\",\"setPassword\",\"mfa\",\"success\",\"help\"]);\n    if (!allowed.has(viewRaw)) {\n      return badRequest(\"Invalid view\");\n    }\n    // Save as-is; router understands \"verify\" mapping\n    session.lastView = viewRaw;\n    return jsonResponse({ ok: true, message: \"Saved\" }, { csp });\n  }\n\n  if (url.pathname === \"/api/request-reset\") {\n    const rl = rateLimitCheck(session, \"request-reset\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const identifier = sanitizeInput(body?.identifier);\n    // Do not reveal if user exists (Security: Avoid user enumeration)\n    // We will generate a token each time. Only tokens bound to a real user will allow proceeding.\n    let userId: string | null = null;\n    for (const u of users.values()) {\n      if (u.username.toLowerCase() === identifier.toLowerCase() || u.email.toLowerCase() === identifier.toLowerCase()) {\n        userId = u.id;\n        break;\n      }\n    }\n    const rt = generateResetToken(userId, session.id);\n    const origin = url.origin.replace(\"http:\", \"https:\"); // enforce https link\n    const link = `${origin}/#/verify?token=${encodeURIComponent(rt.token)}`;\n    // Mirror \"delivery\" via console in the browser — return for demo\n    return jsonResponse({\n      ok: true,\n      message: \"If the account exists, you will receive instructions.\",\n      demo: { token: rt.token, code: rt.code, link }\n    }, { csp });\n  }\n\n  if (url.pathname === \"/api/verify-token\") {\n    const rl = rateLimitCheck(session, \"verify-token\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const tokenOrCode = sanitizeInput(body?.tokenOrCode);\n    let rt: ResetToken | undefined = resetTokens.get(tokenOrCode);\n    if (!rt) {\n      // allow manual code submission\n      if (/^[0-9]{6}$/.test(tokenOrCode)) {\n        rt = findTokenByCode(tokenOrCode);\n      }\n    }\n    const t = now();\n    let canProceed = false;\n    if (rt && !rt.used && t < rt.expiresAt && rt.userId) {\n      rt.used = true; // single-use (Security: tokens single-use and short-lived)\n      session.canSetPassword = true;\n      session.resetUserId = rt.userId;\n      canProceed = true;\n    }\n    return jsonResponse({ ok: true, canProceed, message: \"If valid, you may continue.\" }, { csp });\n  }\n\n  if (url.pathname === \"/api/set-password\") {\n    const rl = rateLimitCheck(session, \"set-password\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    if (!session.canSetPassword || !session.resetUserId) {\n      // Security: Access control to sensitive action (Broken Access Control prevention)\n      return forbidden(\"Not authorized for this action\");\n    }\n    const body = await readJson();\n    const newPassword = String(body?.newPassword || \"\");\n    const policy = checkPasswordPolicy(newPassword);\n    if (!policy.ok) {\n      return jsonResponse({ ok: false, message: \"Password does not meet policy\", reasons: policy.reasons }, { status: 400, csp });\n    }\n    const user = users.get(session.resetUserId);\n    if (!user) {\n      return jsonResponse({ ok: false, message: \"Unexpected error\" }, { status: 500, csp });\n    }\n    const hash = await Bun.password.hash(newPassword, {\n      algorithm: \"argon2id\",\n      memoryCost: 19456,\n      timeCost: 2,\n    });\n    user.passwordHash = hash;\n    // Clear reset state\n    session.canSetPassword = false;\n    session.resetUserId = null;\n    return jsonResponse({ ok: true, message: \"Password updated.\" }, { csp });\n  }\n\n  if (url.pathname === \"/api/login\") {\n    const rl = rateLimitCheck(session, \"login\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const identifier = sanitizeInput(body?.identifier);\n    const password = String(body?.password || \"\");\n    let user: User | undefined;\n    for (const u of users.values()) {\n      if (u.username.toLowerCase() === identifier.toLowerCase() || u.email.toLowerCase() === identifier.toLowerCase()) {\n        user = u; break;\n      }\n    }\n    let demoMfaCode: string | undefined;\n    if (user && await Bun.password.verify(password, user.passwordHash)) {\n      // Valid credentials; generate MFA\n      demoMfaCode = generateMfaForSession(session);\n      // For demo: send code back for console.log panel\n      return jsonResponse({\n        ok: true,\n        message: \"If the credentials are correct, you will be asked for a code.\",\n        demoMfaCode\n      }, { csp });\n    } else {\n      // Do not reveal anything; still generic response\n      return jsonResponse({\n        ok: true,\n        message: \"If the credentials are correct, you will be asked for a code.\"\n      }, { csp });\n    }\n  }\n\n  if (url.pathname === \"/api/mfa-verify\") {\n    const rl = rateLimitCheck(session, \"mfa-verify\", ip);\n    if (!rl.ok) return jsonResponse({ ok: false, message: \"Too many requests. Please wait.\" }, { status: 429, headers: rl.headers, csp });\n\n    const body = await readJson();\n    const code = sanitizeInput(body?.code);\n    let success = false;\n    const ttl = 10 * 60_000;\n    if (session.mfaPending && session.mfaCode && session.mfaGeneratedAt && now() - session.mfaGeneratedAt < ttl) {\n      if (code === session.mfaCode) {\n        success = true;\n        session.authenticated = true;\n        session.mfaPending = false;\n        session.mfaCode = null;\n        session.mfaGeneratedAt = null;\n      }\n    }\n    return jsonResponse({ ok: true, success, message: success ? \"Signed in.\" : \"If the code is correct, you will continue.\" }, { csp });\n  }\n\n  return jsonResponse({ ok: false, message: \"Not found\" }, { status: 404, csp });\n}\n\n// Main request handler\nasync function handler(req: Request, server: any): Promise<Response> {\n  // Enforce HTTPS scheme in links and set strict headers per response\n  const ip = (server?.requestIP?.(req)?.address as string) || req.headers.get(\"x-forwarded-for\") || \"\";\n  const { session, setCookies } = ensureSession(req, ip);\n  const url = new URL(req.url);\n\n  if (url.pathname.startsWith(\"/api/\")) {\n    const res = await handleAPI(req, server, session);\n    const headers = new Headers(res.headers);\n    // propagate cookies and headers\n    for (const c of setCookies) headers.append(\"Set-Cookie\", c);\n    return new Response(await res.text(), { status: res.status, headers });\n  }\n\n  if (url.pathname === \"/\") {\n    const nonce = randomId(12);\n    const csp = buildCSP(nonce);\n    const html = renderHTML(session, nonce);\n    const headers: HeadersInit = {\n      \"Content-Type\": \"text/html; charset=utf-8\",\n      ...securityHeaders({ csp }),\n    };\n    setCookies.push(`lastView=${encodeURIComponent(session.lastView || \"login\")}; Path=/; Secure; HttpOnly; SameSite=Strict; Max-Age=2592000`);\n    const resHeaders = new Headers(headers);\n    for (const c of setCookies) resHeaders.append(\"Set-Cookie\", c);\n    return new Response(html, { status: 200, headers: resHeaders });\n  }\n\n  return new Response(\"Not found\", { status: 404, headers: securityHeaders() });\n}\n\n// Initialize demo user and start server\nawait initDemoUser();\n\n// HTTPS server with provided certificates (Requirements: Security Misconfiguration - HTTPS enforced, HSTS, CSP)\nconst certFile = Bun.file(\"certs/cert.pem\");\nconst keyFile = Bun.file(\"certs/key.pem\");\n\nconst server = Bun.serve({\n  port: 8443,\n  tls: {\n    cert: await certFile.text(),\n    key: await keyFile.text(),\n  },\n  fetch: handler,\n});\n\nconsole.log(`HTTPS server running at https://localhost:${server.port}`);\n", "task_list": [], "evaluator_md": "SUMMARY:\nThe artifact is a single-file Bun HTTPS server (app.ts) delivering a SPA for a password recovery flow. It implements a clear, step-by-step UX with accessibility considerations, works without external assets, and includes deterministic mock deliveries via browser console for testing. Security controls include HTTPS with TLS, HSTS, CSP with nonces, CSRF protection on all POSTs, rate limiting, Argon2id password hashing, MFA, and short-lived, single-use reset tokens. Internal navigation and link-based verification work, and manual code verification is supported. No functional or runtime errors are evident for the described environment (Bun 1.3.0).\n\nFUNCTIONAL_CHECK:\n- Single file (Bun server + Client UI in HTML+CSS+vanilla JS) exists in one file app.ts: PASS — Everything is implemented in app.ts with inline HTML/CSS/JS and server logic.\n- Zero-compilation compliance (no bundlers/tools; Bun runs it directly): PASS — Runs with bun app.ts; no build steps or external assets used.\n- HTTPS with provided TLS certs (certs/cert.pem, certs/key.pem): PASS — Bun.serve configured with TLS using those files.\n- SPA interactivity works in browser (client-side routing, no external network calls): PASS — Hash-based router; all fetches are to /api; no external calls.\n- Password reset flow (request, verify via link or code, set new password) works: PASS — Flow includes request reset, verify token or 6-digit code, set password with policy checks.\n- If there is a verification link, allow manual code entry: PASS — “Verify reset” screen supports both token and 6-digit code.\n- Internal links (e.g., to verification pages or confirmation screens) function: PASS — Generated link uses https://.../#/verify?token=...; router pre-fills the token and shows the verify view.\n- Deterministic mocks via console.log in the browser (show reset token, link, code): PASS — Client logs reset details and MFA code; demo panel mirrors them.\n- Inclusivity: forgiving, clear, step-by-step, no timeouts, low-stress UI: PASS — Step views, progress bar, simple language, help link, status messages, no session timeouts, last-view persistence to resume.\n- Prevents user enumeration: PASS — Generic responses for login/reset; no disclosure if an account exists.\n- CSRF protection unique per session and validated on sensitive requests: PASS — CSRF token per session, sent in header and validated for all POST /api routes.\n- Access control on sensitive routes (no IDOR): PASS — /api/set-password requires session.canSetPassword bound by validated token; session state controls access.\n- Injection (XSS) mitigations: PASS — Inputs sanitized; outputs set via textContent; CSP with nonce; no inline event handlers or external scripts.\n- “No inline or untrusted scripts”: PASS — Inline script allowed via CSP nonce and hosted ‘self’; no third-party scripts.\n- Framework auto-escaping: N/A — No frameworks by requirement; manual escaping and safe DOM APIs are used consistently.\n- Security headers (HTTPS, HSTS, CSP, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, Permissions-Policy): PASS — Set via securityHeaders; CSP generated per response; HSTS enabled.\n- Password reset tokens random, single-use, short-lived: PASS — Random base64url; single-use mark; 15-minute expiry.\n- Debug info/stack traces/directory listing disabled: PASS — Not exposed; minimal server logs only.\n- Password reset links not predictable/interceptable: PASS — Random token; HTTPS link is constructed; only valid for existing user and single-use within TTL.\n- Identification and Authentication: PASS — MFA implemented; strong password policy enforced (12+ chars, classes, no spaces); Argon2id hashing; login/reset endpoints rate-limited; MFA TTL enforced.\n- Throttling/CAPTCHA/lockout on login attempts: PASS — Rate limiting with exponential backoff; CAPTCHA/lockout not required since throttling is present.\n- SSRF/open redirects prevented: PASS — No user-controlled outbound requests; no redirects implemented; origin used only to compose demo link.\n- Social engineering guidance to users: PASS — Help view advises safe practices.\n\nFAILING_ITEMS:\n- None identified that block acceptance.\n\nNEW_TASKS:\n- None.\n\nDECISION:\nPASS", "done": true, "iter": 2, "step": 6}
